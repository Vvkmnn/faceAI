
% Default to the notebook output style

    


% Inherit from the specified cell style.




    
\documentclass[11pt]{article}

    
    
    \usepackage[T1]{fontenc}
    % Nicer default font (+ math font) than Computer Modern for most use cases
    \usepackage{mathpazo}

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % We will generate all images so they have a width \maxwidth. This means
    % that they will get their normal width if they fit onto the page, but
    % are scaled down if they would overflow the margins.
    \makeatletter
    \def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth
    \else\Gin@nat@width\fi}
    \makeatother
    \let\Oldincludegraphics\includegraphics
    % Set max figure width to be 80% of text width, for now hardcoded.
    \renewcommand{\includegraphics}[1]{\Oldincludegraphics[width=.8\maxwidth]{#1}}
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionLabelFormat{nolabel}{}
    \captionsetup{labelformat=nolabel}

    \usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage[utf8x]{inputenc} % Allow utf-8 characters in the tex document
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    

    
    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatability definitions
    \def\gt{>}
    \def\lt{<}
    % Document parameters
    \title{project}
    
    
    

    % Pygments definitions
    
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

    \begin{document}
    
    
    \maketitle
    
    

    
    \section{faceAI}\label{faceai}

    The final Computer Vision project in the
\href{https://www.udacity.com/course/artificial-intelligence-nanodegree--nd889}{Artificial
Intelligence Nanodegree program}!

In this project,we'll combine our knowledge of computer vision
techniques and deep learning to \textbf{build and end-to-end facial
keypoint recognition system!}

\subsection{Setup}\label{setup}

\textbf{Part 1} : Investigating OpenCV, pre-processing, and face
detection

\begin{itemize}
\tightlist
\item
  Section \ref{step0}: Detect Faces Using a Haar Cascade Classifier
\item
  Section \ref{step1}: Add Eye Detection
\item
  Section \ref{step2}: De-noise an Image for Better Face Detection
\item
  Section \ref{step3}: Blur an Image and Perform Edge Detection
\item
  Section \ref{step4}: Automatically Hide the Identity of an Individual
\end{itemize}

\textbf{Part 2} : Training a Convolutional Neural Network (CNN) to
detect facial keypoints

\begin{itemize}
\tightlist
\item
  Section \ref{step5}: Create a CNN to Recognize Facial Keypoints
\item
  Section \ref{step6}: Compile and Train the Model
\item
  Section \ref{step7}: Visualize the Loss and Answer Questions
\end{itemize}

\textbf{Part 3} : Putting parts 1 and 2 together to identify facial
keypoints on any image!

\begin{itemize}
\tightlist
\item
  Section \ref{step7}: Build a Robust Facial Keypoints Detector
  (Complete the CV Pipeline)
\end{itemize}

    \subsection{History}\label{history}

\begin{figure}
\centering
\includegraphics{http://nikhilbuduma.com/img/facial_keypoints.png}
\caption{}
\end{figure}

\textbf{Facial keypoints} are otable points around the eyes, nose, and
mouth on any face and are used in many applications, from facial
tracking to emotion recognition. There are three main parts to this
project:

In this project you will get to explore a few of the many computer
vision algorithms built into the OpenCV library. This expansive computer
vision library is now
\href{https://en.wikipedia.org/wiki/OpenCV\#History}{almost 20 years
old} and still growing!

    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

 \#\# Step 0: Detect Faces Using a Haar Cascade Classifier

Have you ever wondered how Facebook automatically tags images with your
friends' faces with
\href{https://research.fb.com/publications/deepface-closing-the-gap-to-human-level-performance-in-face-verification/}{DeepFace}?
Or how high-end cameras automatically find and focus on a certain
person's face?

Applications like these depend heavily on the machine learning task
known as \emph{face detection} - which is the task of automatically
finding faces in images containing people.

At its root face detection is a \textbf{classification problem -
distinguishing between distinct classes of things.} With face detection
these distinct classes are 1) images of human faces and 2) everything
else.

We use OpenCV's implementation of
\href{http://docs.opencv.org/trunk/d7/d8b/tutorial_py_face_detection.html}{Haar
feature-based cascade classifiers} to detect human faces in images.
OpenCV provides many pre-trained face detectors, stored as XML files on
\href{https://github.com/opencv/opencv/tree/master/data/haarcascades}{github}!

We have downloaded one of these detectors and stored it in the
\texttt{detector\_architectures} directory.

    \subsubsection{Import Resources}\label{import-resources}

In the next python cell, we load in the required libraries for this
section of the project.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}45}]:} \PY{c+c1}{\PYZsh{} Settings}
         \PY{o}{\PYZpc{}}\PY{k}{matplotlib} inline
         
         \PY{c+c1}{\PYZsh{} Libraries}
         \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}              \PY{c+c1}{\PYZsh{} Numpy for array management}
         \PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt} \PY{c+c1}{\PYZsh{} Matplotlib for plotting}
         \PY{k+kn}{import} \PY{n+nn}{math}                     \PY{c+c1}{\PYZsh{} Math for...math?}
         \PY{k+kn}{import} \PY{n+nn}{cv2}                      \PY{c+c1}{\PYZsh{} OpenCV library for computer vision}
         \PY{k+kn}{from} \PY{n+nn}{PIL} \PY{k}{import} \PY{n}{Image}           \PY{c+c1}{\PYZsh{} Python Image Library to handle i}
         \PY{k+kn}{import} \PY{n+nn}{time} 
\end{Verbatim}


    Next, we load in and display a test image for performing face detection.

\emph{Note}: by default OpenCV assumes the ordering of our image's color
channels are Blue, then Green, then Red (BGR). This is \emph{slightly}
out of order with most image types whose color channels are ordered Red,
then Green, then Blue (RGB).

In order to switch the Blue and Red channels of our test image around we
will use OpenCV's \texttt{cvtColor} function, which you can read more
about
\href{http://docs.opencv.org/3.2.0/df/d9d/tutorial_py_colorspaces.html}{here};
but in general, this utility function that can transform it for us, and
do other transformations like converting a color image to grayscale,
transforming a standard color image to
\href{https://en.wikipedia.org/wiki/HSL_and_HSV}{HSV} (Hue, Saturation,
Lightness), etc.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}46}]:} \PY{c+c1}{\PYZsh{} Load in color image for face detection}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{images/test\PYZus{}image\PYZus{}1.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Convert the image to RGB colorspace}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2RGB}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Plot our image using subplots to specify a size and title}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Original Image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}46}]:} <matplotlib.image.AxesImage at 0x1153f70b8>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_7_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    There are a lot of people - and faces - in this picture. 13 faces to be
exact!

In the next code cell, we demonstrate how to use a
\href{https://docs.opencv.org/3.3.0/d7/d8b/tutorial_py_face_detection.html}{Haar
Cascade classifier} to detect all the faces in this test image.

\begin{figure}
\centering
\includegraphics{https://docs.opencv.org/3.3.0/haar_features.jpg}
\caption{}
\end{figure}

This face detector uses information about patterns of intensity in an
image to reliably detect faces under varying light conditions. So, to
use this face detector, we'll first convert the image from color to
grayscale.

\begin{figure}
\centering
\includegraphics{https://docs.opencv.org/3.3.0/haar.png}
\caption{}
\end{figure}

But among these features we calculated, most of them are irrelevant. For
example, consider the image above. Top row shows two good features:

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\item
  The first feature selected seems to focus on the property that the
  region of the eyes is often darker than the region of the nose and
  cheeks.
\item
  The second feature selected relies on the property that the eyes are
  darker than the bridge of the nose.
\end{enumerate}

But the same windows used on cheeks or any other place is irrelevant. So
how do we select the best features out of 160000+ features? We brute
force it with \href{https://en.wikipedia.org/wiki/AdaBoost}{Adaboost}!

We save a set of classifiers for each feature (eyes, nose, ears, etc.
and make sure it can detect that featureset across images, then run that
\textbf{cascade of classifiers} and see if we find faces! Here's someone
smarter explaining it:

\begin{quote}
For this they introduced the concept of Cascade of Classifiers. Instead
of applying all the 6000 features on a window, group the features into
different stages of classifiers and apply one-by-one. (Normally first
few stages will contain very less number of features). If a window fails
the first stage, discard it. We don't consider remaining features on it.
If it passes, apply the second stage of features and continue the
process. The window which passes all stages is a face region. How is the
plan !!!
\end{quote}

\begin{figure}
\centering
\includegraphics{https://docs.opencv.org/3.3.0/face.jpg}
\caption{}
\end{figure}

Luckily, these guys even saved a fully trained architecture of the face
detector -\/- found in the file
\emph{haarcascade\_frontalface\_default.xml} - and we can use it on our
image to find faces! (To learn more about the parameters of the detector
see
\href{https://stackoverflow.com/questions/20801015/recommended-values-for-opencv-detectmultiscale-parameters}{this
post}.)

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}47}]:} \PY{c+c1}{\PYZsh{} Convert the RGB  image to grayscale}
         \PY{n}{gray} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}RGB2GRAY}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Extract the pre\PYZhy{}trained face detector from an xml file}
         \PY{c+c1}{\PYZsh{} This Haar Cascade Classifier specializes in frontal face detection!}
         \PY{n}{face\PYZus{}cascade} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{CascadeClassifier}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{detector\PYZus{}architectures/haarcascade\PYZus{}frontalface\PYZus{}default.xml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Detect the faces in image (Define bounding dimensions for the box)}
         \PY{n}{faces} \PY{o}{=} \PY{n}{face\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{gray}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Print the number of faces detected in the image}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Number of faces detected:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n+nb}{len}\PY{p}{(}\PY{n}{faces}\PY{p}{)}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Make a copy of the orginal image to draw face detections on}
         \PY{n}{image\PYZus{}with\PYZus{}detections} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{image}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Get the bounding box for each detected face}
         \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{faces}\PY{p}{:}
             \PY{c+c1}{\PYZsh{} Add a red bounding box to the detections image}
             \PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{,}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
             
         
         \PY{c+c1}{\PYZsh{} Display the image with the detections}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image with Face Detections}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Number of faces detected: 13

    \end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}47}]:} <matplotlib.image.AxesImage at 0x11543c940>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_9_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}48}]:} \PY{n+nb}{print}\PY{p}{(}\PY{n}{faces}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
[[1295   94   96   96]
 [ 917  103   96   96]
 [1146  132   96   96]
 [ 684  150   96   96]
 [ 510  156   96   96]
 [1565  339   96   96]
 [ 588  390   96   96]
 [1158  391   96   96]
 [ 773  404   96   96]
 [1345  411   96   96]
 [ 383  414   96   96]
 [ 147  459   96   96]
 [ 996  526   96   96]]

    \end{Verbatim}

    In the above code, \texttt{faces} is a numpy array, holding of detected
faces! Awesome!

Here each row corresponds to a detected face, where each detected face
is a 1D array with four entries that specifies the bounding box of the
detected face: * \texttt{x}: The horizontal position of the detection
box. * \texttt{y}: The vertical position of the detection box. *
\texttt{w}: The width of the detection box. * \texttt{h}: The height of
the detection box.

If you think this depends a lot on the notion of this 'box', you're
right! Shrinking or widening the shape of our bounding box,
significanlty impacts our face detection ability. Let's see if we can
improve our performance with even more features!

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}49}]:} \PY{n}{faces\PYZus{}smallbox} \PY{o}{=} \PY{n}{face\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{gray}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
         \PY{n}{faces\PYZus{}mediumbox} \PY{o}{=} \PY{n}{face\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{gray}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{)}
         \PY{n}{faces\PYZus{}bigbox} \PY{o}{=} \PY{n}{face\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{gray}\PY{p}{,} \PY{l+m+mi}{7}\PY{p}{,} \PY{l+m+mi}{7}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Get the bounding box for each detected face}
         \PY{k}{def} \PY{n+nf}{faceFinder}\PY{p}{(}\PY{n}{face\PYZus{}vector}\PY{p}{)}\PY{p}{:} 
             \PY{c+c1}{\PYZsh{} Print the number of faces detected in the image}
             \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Number of faces detected:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n+nb}{len}\PY{p}{(}\PY{n}{face\PYZus{}vector}\PY{p}{)}\PY{p}{)}
         
             \PY{c+c1}{\PYZsh{} Make a copy of the orginal image to draw face detections on}
             \PY{n}{image\PYZus{}with\PYZus{}detections} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{image}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{} Add a red bounding box to the detections image}
             \PY{p}{[}\PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{,}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)} \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{face\PYZus{}vector}\PY{p}{]}
         
             \PY{c+c1}{\PYZsh{} Display the image with the detections}
             \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{)}\PY{p}{)}
             \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
             \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
             \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
             \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image with Face Detections}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
             \PY{k}{return} \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{)}
             
         \PY{n}{faceFinder}\PY{p}{(}\PY{n}{faces\PYZus{}smallbox}\PY{p}{)}
         \PY{n}{faceFinder}\PY{p}{(}\PY{n}{faces\PYZus{}mediumbox}\PY{p}{)}
         \PY{n}{faceFinder}\PY{p}{(}\PY{n}{faces\PYZus{}bigbox}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Number of faces detected: 6
Number of faces detected: 10
Number of faces detected: 0

    \end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}49}]:} <matplotlib.image.AxesImage at 0x146566e48>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_12_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_12_3.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_12_4.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Step 1: Add Eye Detections}\label{step-1-add-eye-detections}

Luckily, there are even more pre-trained detectors available that use a
Haar Cascade Classifier - including full human body detectors, license
plate detectors, and more! Since this strategy just depends on having
cascades of valid classifiers, we can put a ton in a row and detect
more!

\href{https://github.com/opencv/opencv/tree/master/data/haarcascades}{A
full list of the pre-trained architectures can be found here}.

    To test your eye detector, we'll first read in a new test image with
just a single face.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}50}]:} \PY{c+c1}{\PYZsh{} Load in color image for face detection}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{images/james.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Convert the image to RGB colorspace}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2RGB}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Plot the RGB image}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Original Image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}50}]:} <matplotlib.image.AxesImage at 0x1464c6d30>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_15_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    Notice that even though the image is an original black and white image,
we \emph{have to read it in} as a color image that will still need to be
converted to grayscale in order to perform the accurate face detection.

So, let's convert this image to grayscale, then load OpenCV's face
detector and run it with parameters that detect this face accurately.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{c+c1}{\PYZsh{} Convert the image to Gray color space}
        \PY{n}{gray} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}RGB2GRAY}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Plot the RGB image}
        \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{)}
        \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Original Image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}7}]:} <matplotlib.image.AxesImage at 0x10f59fcc0>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_17_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{c+c1}{\PYZsh{} Extract the pre\PYZhy{}trained face detector from an xml file}
        \PY{c+c1}{\PYZsh{} This feature still uses frontal face detection}
        \PY{n}{face\PYZus{}cascade} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{CascadeClassifier}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{detector\PYZus{}architectures/haarcascade\PYZus{}frontalface\PYZus{}default.xml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Detect the faces in image}
        \PY{n}{faces} \PY{o}{=} \PY{n}{face\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{gray}\PY{p}{,} \PY{l+m+mf}{1.25}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Print the number of faces detected in the image}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Number of faces detected:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n+nb}{len}\PY{p}{(}\PY{n}{faces}\PY{p}{)}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Make a copy of the orginal image to draw face detections on}
        \PY{n}{image\PYZus{}with\PYZus{}detections} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{image}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Get the bounding box for each detected face}
        \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{faces}\PY{p}{:}
            \PY{c+c1}{\PYZsh{} Add a red bounding box to the detections image}
            \PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{,}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
            
        
        \PY{c+c1}{\PYZsh{} Display the image with the detections}
        \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{)}
        \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image with Face Detection}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Number of faces detected: 1

    \end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}8}]:} <matplotlib.image.AxesImage at 0x116faa5c0>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_18_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsubsection{Add an eye detector to the current face detection
setup.}\label{add-an-eye-detector-to-the-current-face-detection-setup.}

let's build a Haar-cascade eye detector that can be included in the same
way that the face detector was!

    To set up an eye detector, we use the stored parameters of the eye
cascade detector, called \texttt{haarcascade\_eye.xml}, located in the
\texttt{detector\_architectures} subdirectory. Things to note:

\begin{itemize}
\item
  First, let's make sure to give our loaded eye detector the variable
  name (\texttt{eye\_cascade}). We give the list of eye regions you
  detect the variable name (\texttt{eyes}).
\item
  Second, since we've already run the face detector over this image, we
  should only search for eyes \emph{within the rectangular face regions
  detected in \texttt{faces}} (overlay classifiers!) This will minimize
  false detections, since there's a way to pre test it!
\end{itemize}

Lastly, once you've run your eye detector over the facial detection
region, you should display the RGB image with both the face detection
boxes (in red) and your eye detections (in green) to verify that
everything works as expected.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{c+c1}{\PYZsh{} Make a copy of the original image to plot rectangle detections}
        \PY{n}{image\PYZus{}with\PYZus{}detections} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{image}\PY{p}{)}   
        
        \PY{c+c1}{\PYZsh{} Loop over the detections and draw their corresponding face detection boxes}
        \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{faces}\PY{p}{:}
            \PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{,}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{)}\PY{p}{,}\PY{p}{(}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}  
            
        \PY{c+c1}{\PYZsh{} Do not change the code above this comment!}
        
            
        \PY{c+c1}{\PYZsh{}\PYZsh{} Add eye detection, using haarcascade\PYZus{}eye.xml, to the current face detector algorithm}
        \PY{c+c1}{\PYZsh{} Build on the existing cv2 object}
        \PY{n}{eye\PYZus{}cascade} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{CascadeClassifier}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{detector\PYZus{}architectures/haarcascade\PYZus{}eye.xml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{eyes} \PY{o}{=} \PY{n}{eye\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{,} \PY{l+m+mf}{1.05}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{}\PYZsh{} Loop over the eye detections and draw their corresponding boxes in green on image\PYZus{}with\PYZus{}detections}
        \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{eyes}\PY{p}{:}
            \PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{,}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{)}\PY{p}{,}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Plot the image with both faces and eyes detected}
        \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{)}
        \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image with Face and Eye Detection}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}9}]:} <matplotlib.image.AxesImage at 0x10c989710>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_21_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{c+c1}{\PYZsh{} Call the laptop camera face/eye detector function above}
         \PY{c+c1}{\PYZsh{} laptop\PYZus{}camera\PYZus{}go()}
\end{Verbatim}


    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Step 2: De-noise an Image for Better Face
Detection}\label{step-2-de-noise-an-image-for-better-face-detection}

    Image quality is an important aspect of any computer vision task.

Typically, when creating a set of images to train a deep learning
network, significant care is taken to ensure that training images are
free of visual noise or artifacts that hinder object detection. While
computer vision algorithms - like a face detector - are typically
trained on 'nice' data such as this, \textbf{new test data doesn't
always look so nice!}

\subsubsection{Pre Processing}\label{pre-processing}

When applying a trained computer vision algorithm to a new piece of test
data one often cleans it up first before feeding it in.

This sort of cleaning - referred to as \emph{pre-processing} - can
include a number of cleaning phases like blurring, de-noising, color
transformations, etc., and many of these tasks can be accomplished using
OpenCV.

In this short subsection we explore OpenCV's noise-removal functionality
to see how we can clean up a noisy image, which we then feed into our
trained face detector!

    \subsubsection{Create a noisy image to work
with}\label{create-a-noisy-image-to-work-with}

In the next cell, we create an artificial noisy version of the previous
multi-face image. This is a little exaggerated - we don't typically get
images that are this noisy - but
\href{https://digital-photography-school.com/how-to-avoid-and-reduce-noise-in-your-images/}{image
noise}, or 'grainy-ness' in a digitial image - is a fairly common
phenomenon.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{c+c1}{\PYZsh{} Load in the multi\PYZhy{}face test image again}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{images/test\PYZus{}image\PYZus{}1.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Convert the image copy to RGB colorspace}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2RGB}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Make an array copy of this image}
         \PY{n}{image\PYZus{}with\PYZus{}noise} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{asarray}\PY{p}{(}\PY{n}{image}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Create noise \PYZhy{} here we add noise sampled randomly from a Gaussian distribution: a common model for noise}
         \PY{n}{noise\PYZus{}level} \PY{o}{=} \PY{l+m+mi}{40}
         \PY{n}{noise} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{randn}\PY{p}{(}\PY{n}{image}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{image}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{n}{image}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}\PY{o}{*}\PY{n}{noise\PYZus{}level}
         
         \PY{c+c1}{\PYZsh{} Add this noise to the array image copy}
         \PY{n}{image\PYZus{}with\PYZus{}noise} \PY{o}{=} \PY{n}{image\PYZus{}with\PYZus{}noise} \PY{o}{+} \PY{n}{noise}
         
         \PY{c+c1}{\PYZsh{} Convert back to uint8 format}
         \PY{n}{image\PYZus{}with\PYZus{}noise} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{asarray}\PY{p}{(}\PY{p}{[}\PY{n}{np}\PY{o}{.}\PY{n}{uint8}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{clip}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{255}\PY{p}{)}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n}{image\PYZus{}with\PYZus{}noise}\PY{p}{]}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Plot our noisy image!}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Noisy Image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}noise}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}12}]:} <matplotlib.image.AxesImage at 0x10c966a58>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_26_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    In the context of face detection, the problem with an image like this is
that - due to noise - we may miss some faces or get false detections.

In the next cell we apply the same trained OpenCV detector with the same
settings as before. Let's see what sort of detections we get!

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{c+c1}{\PYZsh{} Convert the RGB  image to grayscale}
         \PY{n}{gray\PYZus{}noise} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}noise}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}RGB2GRAY}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Extract the pre\PYZhy{}trained face detector from an xml file}
         \PY{n}{face\PYZus{}cascade} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{CascadeClassifier}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{detector\PYZus{}architectures/haarcascade\PYZus{}frontalface\PYZus{}default.xml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Detect the faces in image}
         \PY{n}{faces} \PY{o}{=} \PY{n}{face\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{gray\PYZus{}noise}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Print the number of faces detected in the image}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Number of faces detected:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n+nb}{len}\PY{p}{(}\PY{n}{faces}\PY{p}{)}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Make a copy of the orginal image to draw face detections on}
         \PY{n}{image\PYZus{}with\PYZus{}detections} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}noise}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Get the bounding box for each detected face}
         \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{faces}\PY{p}{:}
             \PY{c+c1}{\PYZsh{} Add a red bounding box to the detections image}
             \PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{,}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
             
         
         \PY{c+c1}{\PYZsh{} Display the image with the detections}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Noisy Image with Face Detections}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Number of faces detected: 12

    \end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}13}]:} <matplotlib.image.AxesImage at 0x11413acf8>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_28_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    With this added noise we now miss one of the faces we had before!

Let's build in a pre-processing step to ensure we don't have this issue.

    \subsubsection{De-noise this image for better face
detection}\label{de-noise-this-image-for-better-face-detection}

Time to get our hands dirty: using OpenCV's built in color image
de-noising functionality called \texttt{fastNlMeansDenoisingColored()},
let's de-noise this image enough so that all the faces in the image are
properly detected, and we can run it through our trained face detector.

What is \textbf{noise}? Noise is the arbitrary error of measurement.
Using that notion, we can construct is a stochastic function, typically
a random, normally distributed variable with zero mean.

For images, consider a noisy pixel, p = p\_0 + n where p\_0 is the true
value of pixel and n is the noise in that pixel. You can take large
number of same pixels (say N) from different images and computes their
average. Ideally, you should get p = p\_0, since mean of noise is zero,
and over multiple samples the noisiness should cancel itself out

You can find its {[}official documentation
here{]}(\href{http://docs.opencv.org/trunk/d1/d79/group__photo__denoise.html\#ga21abc1c8b0e15f78cd3eff672cb6c476}{documentation
for denoising} and
\href{http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_photo/py_non_local_means/py_non_local_means.html}{a
useful example here}, but here's the short version of what's happening:

\begin{figure}
\centering
\includegraphics{http://opencv-python-tutroals.readthedocs.io/en/latest/_images/nlm_patch.jpg}
\caption{}
\end{figure}

\begin{quote}
The blue patches in the image looks the similar. Green patches looks
similar. So we take a pixel, take small window around it, search for
similar windows in the image, average all the windows and replace the
pixel with the result we got. This method is Non-Local Means Denoising.
It takes more time compared to blurring techniques we saw earlier, but
its result is very good. More
\href{http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_photo/py_non_local_means/py_non_local_means.html}{details
and online demo can be found at first link in additional resources.}
\end{quote}

\textbf{Note:} you can keep all parameters \emph{except}
\texttt{photo\_render} fixed as shown in the second link above. Play
around with the value of this parameter - see how it affects the
resulting cleaned image.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{c+c1}{\PYZsh{} \PYZpc{}timeit!}
         \PY{c+c1}{\PYZsh{}\PYZsh{} Use OpenCV\PYZsq{}s built in color image de\PYZhy{}noising function to clean up our noisy image!}
         
         \PY{c+c1}{\PYZsh{} fastNlMeansDenoisingColored(src[, dst[, h[, hColor[, templateWindowSize[, searchWindowSize]]]]])}
         \PY{n}{denoised\PYZus{}image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{fastNlMeansDenoisingColored}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}noise}\PY{p}{,}\PY{k+kc}{None}\PY{p}{,}\PY{l+m+mi}{19}\PY{p}{,}\PY{l+m+mi}{19}\PY{p}{,}\PY{l+m+mi}{7}\PY{p}{,}\PY{l+m+mi}{21}\PY{p}{)}
\end{Verbatim}


    A notably expensive algorithm, but since it's using k-means clustering
to generate consistent structure from noisy little windows, maybe it'll
get our face detection back!

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{c+c1}{\PYZsh{} Convert the RGB  image to grayscale}
         \PY{n}{gray\PYZus{}denoise} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{denoised\PYZus{}image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}RGB2GRAY}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Extract the pre\PYZhy{}trained face detector from an xml file}
         \PY{n}{face\PYZus{}cascade} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{CascadeClassifier}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{detector\PYZus{}architectures/haarcascade\PYZus{}frontalface\PYZus{}default.xml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Detect the faces in image}
         \PY{n}{faces} \PY{o}{=} \PY{n}{face\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{gray\PYZus{}denoise}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Print the number of faces detected in the image}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Number of faces detected:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n+nb}{len}\PY{p}{(}\PY{n}{faces}\PY{p}{)}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Make a copy of the orginal image to draw face detections on}
         \PY{n}{denoised\PYZus{}image\PYZus{}with\PYZus{}detections} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{denoised\PYZus{}image}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Get the bounding box for each detected face}
         \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{faces}\PY{p}{:}
             \PY{c+c1}{\PYZsh{} Add a red bounding box to the detections image}
             \PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{denoised\PYZus{}image\PYZus{}with\PYZus{}detections}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{,}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
             
         \PY{c+c1}{\PYZsh{} Display the image with the detections}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Denoised Image with Face Detections}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{denoised\PYZus{}image\PYZus{}with\PYZus{}detections}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Number of faces detected: 13

    \end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}15}]:} <matplotlib.image.AxesImage at 0x11d7f07b8>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_33_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Step 3: Blur an Image and Perform Edge
Detection}\label{step-3-blur-an-image-and-perform-edge-detection}

    Now that we have developed a simple pipeline for detecting faces using
OpenCV - let's start playing around with a few fun things we can do with
all those detected faces!

    \subsubsection{Importance of Blur in Edge
Detection}\label{importance-of-blur-in-edge-detection}

Edge detection is a concept that pops up almost everywhere in computer
vision applications, as edge-based features (as well as features built
on top of edges) are often some of the best features for e.g., object
detection and recognition problems.

Edge detection is a \emph{dimension reduction} technique - by keeping
only the edges of an image we get to throw away a lot of
non-discriminating information! This way, we only preserve the most
important, global structures (ignoring local structures that aren't very
discriminative).

As you can imagine, removing irrelevent local structures is a crucial
pre-processing step to performing edge detection in an image, and it
turns out \textbf{blurring} can do just that!

Below is an animated gif showing the result of an edge-detected cat
\href{https://en.wikipedia.org/wiki/Gaussian_blur\#Common_uses}{taken
from Wikipedia}, where the image is gradually blurred more and more
prior to edge detection.

When the animation begins you can't quite make out what it's a picture
of, but as the animation evolves \textbf{local structures are removed
via blurring the cat becomes visible in the edge-detected image.}

Edge detection is a \textbf{convolution} performed on the image itself,
and you can read about Canny edge detection on
\href{http://docs.opencv.org/2.4/doc/tutorials/imgproc/imgtrans/canny_detector/canny_detector.html}{this
OpenCV documentation page}.

    \subsubsection{Canny edge detection}\label{canny-edge-detection}

In the cell below we load in a test image, then apply \emph{Canny edge
detection} on it. The original image is on the left, and the
edge-detected version is on the right.

Notice how the result looks very busy - there are too many little
details preserved in the image before it is sent to the edge detector!

When applied in computer vision applications, edge detection should
preserve \emph{global} structure; doing away with local structures that
don't help describe what objects are in the image.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{c+c1}{\PYZsh{} Load in the image}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{images/fawzia.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Convert to RGB colorspace}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2RGB}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Convert to grayscale}
         \PY{n}{gray} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}RGB2GRAY}\PY{p}{)}  
         
         \PY{c+c1}{\PYZsh{} Perform Canny edge detection}
         \PY{n}{edges} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{Canny}\PY{p}{(}\PY{n}{gray}\PY{p}{,}\PY{l+m+mi}{100}\PY{p}{,}\PY{l+m+mi}{200}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Dilate the image to amplify edges}
         \PY{n}{edges} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{dilate}\PY{p}{(}\PY{n}{edges}\PY{p}{,} \PY{k+kc}{None}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Plot the RGB and edge\PYZhy{}detected image}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{15}\PY{p}{,}\PY{l+m+mi}{15}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{121}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Original Image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image}\PY{p}{)}
         
         \PY{n}{ax2} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{122}\PY{p}{)}
         \PY{n}{ax2}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax2}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax2}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Canny Edges}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax2}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{edges}\PY{p}{,} \PY{n}{cmap}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{gray}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}16}]:} <matplotlib.image.AxesImage at 0x11d764ef0>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_38_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    Without first blurring the image, and removing small, local structures,
a lot of irrelevant edge content gets picked up and amplified by the
detector (as shown in the right panel above).

    \subsubsection{\texorpdfstring{Blur the image \emph{then} perform edge
detection}{Blur the image then perform edge detection}}\label{blur-the-image-then-perform-edge-detection}

So, instead of all these fine details, lets blur our image and figure
out we're \emph{generally} looking at, i.e. dropping local noise for
global structure!

In the next cell, we will repeat this experiment - blurring the image
first to remove these local structures, so that only the important
boudnary details remain in the edge-detected image.

Lets blur the image by using OpenCV's \texttt{filter2d()} functionality
- which is discussed in
\href{http://docs.opencv.org/3.1.0/d4/d13/tutorial_py_filtering.html}{this
documentation page} - and use an \emph{averaging kernel} of width equal
to 4.

So what's going on within the function? In general, convolution is an
operation between every part of an image and an operator (kernel); using
linear algebra to transform image matrices!

A \textbf{kernel is essentially a fixed size array of numerical
coefficeints along with an anchor point in that array, which is
tipically located at the center.}

\begin{figure}
\centering
\includegraphics{https://docs.opencv.org/2.4/_images/filter_2d_tutorial_kernel_theory.png}
\caption{}
\end{figure}

Therefore, the value of a convolution is calculated in the following
way:

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\tightlist
\item
  Place the kernel anchor on top of a determined pixel, with the rest of
  the kernel overlaying the corresponding local pixels in the image.
\item
  Multiply the kernel coefficients by the corresponding image pixel
  values and sum the result.
\item
  Place the result to the location of the anchor in the input image.
\item
  Repeat for all pixels by scanning the kernel over the entire image.
\end{enumerate}

Expressing the procedure above in the form of an equation we would have:

\$ H(x,y) = \sum\emph{\{i=0\}\^{}\{M}\{i\} - 1\}
\sum\emph{\{j=0\}\^{}\{M}\{j\}-1\} I(x+i - a\_\{i\}, y + j -
a\_\{j\})K(i,j) \$

Fortunately,
\href{https://docs.opencv.org/2.4/doc/tutorials/imgproc/imgtrans/filter_2d/filter_2d.html}{OpenCV}
provides you with the function \texttt{filter2D()} so you do not have to
code all these operations!

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} Blur the test imageusing OpenCV\PYZsq{}s filter2d functionality, }
         
         \PY{c+c1}{\PYZsh{} Load in the image}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{images/fawzia.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Convert to RGB colorspace}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2RGB}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Convert to grayscale}
         \PY{n}{gray} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}RGB2GRAY}\PY{p}{)}  
         
         \PY{c+c1}{\PYZsh{} Use an averaging kernel, and a kernel width equal to 4}
         \PY{n}{kernel} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{ones}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{,}\PY{n}{np}\PY{o}{.}\PY{n}{float32}\PY{p}{)}\PY{o}{/}\PY{l+m+mi}{16}
         \PY{n}{blurred} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{filter2D}\PY{p}{(}\PY{n}{gray}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{kernel}\PY{p}{)}
             
         \PY{c+c1}{\PYZsh{} Perform Canny edge detection}
         \PY{n}{edges} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{Canny}\PY{p}{(}\PY{n}{blurred}\PY{p}{,}\PY{l+m+mi}{100}\PY{p}{,}\PY{l+m+mi}{200}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Dilate the image to amplify edges}
         \PY{n}{edges} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{dilate}\PY{p}{(}\PY{n}{edges}\PY{p}{,} \PY{k+kc}{None}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Plot the RGB and edge\PYZhy{}detected image}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{15}\PY{p}{,}\PY{l+m+mi}{15}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{121}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Original Image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image}\PY{p}{)}
         
         \PY{n}{ax2} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{122}\PY{p}{)}
         \PY{n}{ax2}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax2}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax2}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Canny Edges}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax2}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{edges}\PY{p}{,} \PY{n}{cmap}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{gray}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}17}]:} <matplotlib.image.AxesImage at 0x10f6cb0f0>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_41_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Step 4: Automatically Hide the Identity of an
Individual}\label{step-4-automatically-hide-the-identity-of-an-individual}

For a documentary or reality TV, we often must get permission from every
individual shown on film before you can show their face,
\textbf{otherwise you need to blur it out - by blurring the face a lot}.
Let's figure out how!

This is also true for projects like
\href{https://www.google.com/streetview/}{Google's StreetView maps} - an
enormous collection of mapping images taken from a fleet of Google
vehicles; \textbf{because it would be impossible for Google to get the
permission of every single person accidentally captured in one of these
images they blur out everyone's faces, the detected images must
automatically blur the identity of detected people.} Here's a few
examples of folks caught in the camera of a Google street view vehicle:

 

    \subsubsection{Read in an image to perform identity
detection}\label{read-in-an-image-to-perform-identity-detection}

Let's try this out for ourselves. Use the face detection pipeline built
above and what you know about using the \texttt{filter2D} to blur and
image, and use these in tandem to hide the identity of the person in the
following image - loaded in and printed in the next cell.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}41}]:} \PY{c+c1}{\PYZsh{} Load in the image}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{images/gus.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Convert the image to RGB colorspace}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2RGB}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Display the image}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Original Image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}41}]:} <matplotlib.image.AxesImage at 0x11c4e2e48>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_44_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsubsection{Use blurring to hide the identity of an individual in an
image}\label{use-blurring-to-hide-the-identity-of-an-individual-in-an-image}

Let's identify a face, then blur it out!

Our code should:

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\item
  Automatically detect the face in this image (we've got this bit)
\item
  Blur it out!
\end{enumerate}

Make sure to adjust the parameters of the \emph{averaging} blur filter
to completely obscure this person's identity.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}44}]:} \PY{c+c1}{\PYZsh{}Copy image}
         \PY{n}{image\PYZus{}with\PYZus{}blur\PYZus{}face} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{image}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{}image = cv2.cvtColor(image, cv2.COLOR\PYZus{}RGB2BGR)}
         \PY{n}{gray} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}RGB2GRAY}\PY{p}{)}
         \PY{n}{face\PYZus{}cascade} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{CascadeClassifier}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{detector\PYZus{}architectures/haarcascade\PYZus{}frontalface\PYZus{}default.xml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Detect the faces in image using the Haar Caascade classifier}
         \PY{n}{faces} \PY{o}{=} \PY{n}{face\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{gray}\PY{p}{,} \PY{l+m+mf}{1.13}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Using averaging blur filter, with a big ol\PYZsq{} scaled kernel of 1s}
         \PY{c+c1}{\PYZsh{} Make all these values tend to 1 }
         \PY{n}{kernel} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{ones}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{80}\PY{p}{,} \PY{l+m+mi}{80}\PY{p}{)}\PY{p}{,}\PY{n}{np}\PY{o}{.}\PY{n}{float32}\PY{p}{)} \PY{o}{/} \PY{l+m+mi}{6400}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{kernel}\PY{p}{)}    
         
         \PY{c+c1}{\PYZsh{}\PYZsh{} Blur the bounding box around each detected face using an averaging filter and display the result}
         \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{faces}\PY{p}{:}
             \PY{c+c1}{\PYZsh{} Too small \PYZhy{} filtering mistakes; scale up!}
             \PY{k}{if}\PY{p}{(}\PY{n}{w} \PY{o}{\PYZlt{}} \PY{l+m+mi}{100}\PY{p}{)} \PY{o}{|} \PY{p}{(}\PY{n}{h} \PY{o}{\PYZlt{}} \PY{l+m+mi}{100}\PY{p}{)}\PY{p}{:}
                 \PY{k}{continue}  
             \PY{c+c1}{\PYZsh{} Blur bounding box to the detections image}
             \PY{n}{image\PYZus{}with\PYZus{}blur\PYZus{}face}\PY{p}{[}\PY{n}{y}\PY{p}{:}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{,} \PY{n}{x}\PY{p}{:}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{]} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{filter2D}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}blur\PYZus{}face}\PY{p}{[}\PY{n}{y}\PY{p}{:}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{,} \PY{n}{x}\PY{p}{:}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{]}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{kernel}\PY{p}{)}
           
         \PY{c+c1}{\PYZsh{} Display the image}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image with blur face}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}blur\PYZus{}face}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
[[0.00015625 0.00015625 0.00015625 {\ldots} 0.00015625 0.00015625 0.00015625]
 [0.00015625 0.00015625 0.00015625 {\ldots} 0.00015625 0.00015625 0.00015625]
 [0.00015625 0.00015625 0.00015625 {\ldots} 0.00015625 0.00015625 0.00015625]
 {\ldots}
 [0.00015625 0.00015625 0.00015625 {\ldots} 0.00015625 0.00015625 0.00015625]
 [0.00015625 0.00015625 0.00015625 {\ldots} 0.00015625 0.00015625 0.00015625]
 [0.00015625 0.00015625 0.00015625 {\ldots} 0.00015625 0.00015625 0.00015625]]

    \end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}44}]:} <matplotlib.image.AxesImage at 0x115376198>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_46_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Step 5: Create a CNN to Recognize Facial
Keypoints}\label{step-5-create-a-cnn-to-recognize-facial-keypoints}

Alright, we're ready to recognize faces!

In practice, the \href{https://opencv.org/}{OpenCV Library} is often
used with other machine learning and deep learning libraries to produce
interesting results.

In this stage of the project we will create our own end-to-end pipeline
- employing convolutional networks in keras along with OpenCV - to apply
a "selfie" filter to streaming video and images.

We will start by creating and then training a convolutional network that
can detect facial keypoints in a small dataset of cropped images of
human faces. Then, we'll use OpenCV to expand our detection algorithm to
more general images.

First things first, What are \textbf{facial keypoints}? Let's take a
look at some examples.

Facial keypoints (also called facial landmarks) are the small blue-green
dots shown on each of the faces in the image above - there are 15
keypoints marked in each image. They mark important areas of the face -
the eyes, corners of the mouth, the nose, etc.

Facial keypoints can be used in a variety of machine learning
applications from face and emotion recognition to commercial
applications like the image filters popularized by Snapchat.

\begin{figure}
\centering
\includegraphics{https://www.yourtango.com/sites/default/files/snap1.gif}
\caption{}
\end{figure}

Below we illustrate a filter that, using the results of this section,
automatically places sunglasses on people in images (using the facial
keypoints to place the glasses correctly on each face). Here, the facial
keypoints have been colored lime green for visualization purposes:

    \subsubsection{Make a facial keypoint
detector}\label{make-a-facial-keypoint-detector}

So, how can we make a facial keypoint detector?

Well, at a high level, notice that facial keypoint detection is a
\emph{regression problem}: A single face corresponds to a set of 15
facial keypoints (a set of 15 corresponding \((x, y)\) coordinates,
i.e., an output point).

Because our input data are images, we can employ a \emph{convolutional
neural network} to recognize patterns in our images and learn how to
identify these keypoint given sets of labeled data.

In order to train a regressor, we need a training set - a set of facial
image / facial keypoint pairs to train on. For this we will be using
\href{https://www.kaggle.com/c/facial-keypoints-detection/data}{this
dataset from Kaggle}.

\begin{figure}
\centering
\includegraphics{https://kaggle2.blob.core.windows.net/competitions/kaggle/3486/logos/front_page.png}
\caption{}
\end{figure}

    We've already downloaded this data and placed it in the \texttt{data}
directory. Make sure that you have both the \emph{training} and
\emph{test} data files!

The training dataset contains several thousand \(96 \times 96\)
grayscale images of cropped human faces, along with each face's 15
corresponding facial keypoints (also called landmarks) that have been
placed by hand (!), and recorded in \((x, y)\) coordinates.

This wonderful resource also has a substantial testing set, which we
will use in tinkering with our convolutional network!

\subsubsection{Load Data}\label{load-data}

To load in this data, run the Python cell below - notice we will load in
both the training and testing sets.

The \texttt{load\_data()} function is in the included in the handy
\texttt{utils.py} file.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}22}]:} \PY{k+kn}{from} \PY{n+nn}{utils} \PY{k}{import} \PY{o}{*}
         
         \PY{c+c1}{\PYZsh{} Load training set}
         \PY{n}{X\PYZus{}train}\PY{p}{,} \PY{n}{y\PYZus{}train} \PY{o}{=} \PY{n}{load\PYZus{}data}\PY{p}{(}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{X\PYZus{}train.shape == }\PY{l+s+si}{\PYZob{}\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{o}{.}\PY{n}{format}\PY{p}{(}\PY{n}{X\PYZus{}train}\PY{o}{.}\PY{n}{shape}\PY{p}{)}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{y\PYZus{}train.shape == }\PY{l+s+si}{\PYZob{}\PYZcb{}}\PY{l+s+s2}{; y\PYZus{}train.min == }\PY{l+s+si}{\PYZob{}:.3f\PYZcb{}}\PY{l+s+s2}{; y\PYZus{}train.max == }\PY{l+s+si}{\PYZob{}:.3f\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{o}{.}\PY{n}{format}\PY{p}{(}
             \PY{n}{y\PYZus{}train}\PY{o}{.}\PY{n}{shape}\PY{p}{,} \PY{n}{y\PYZus{}train}\PY{o}{.}\PY{n}{min}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{n}{y\PYZus{}train}\PY{o}{.}\PY{n}{max}\PY{p}{(}\PY{p}{)}\PY{p}{)}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Load testing set}
         \PY{n}{X\PYZus{}test}\PY{p}{,} \PY{n}{\PYZus{}} \PY{o}{=} \PY{n}{load\PYZus{}data}\PY{p}{(}\PY{n}{test}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{X\PYZus{}test.shape == }\PY{l+s+si}{\PYZob{}\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{o}{.}\PY{n}{format}\PY{p}{(}\PY{n}{X\PYZus{}test}\PY{o}{.}\PY{n}{shape}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
/Users/vivek.menon/.anaconda/envs/aind-cv/lib/python3.5/site-packages/h5py/\_\_init\_\_.py:36: FutureWarning: Conversion of the second argument of issubdtype from `float` to `np.floating` is deprecated. In future, it will be treated as `np.float64 == np.dtype(float).type`.
  from .\_conv import register\_converters as \_register\_converters
Using TensorFlow backend.

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
X\_train.shape == (2140, 96, 96, 1)
y\_train.shape == (2140, 30); y\_train.min == -0.920; y\_train.max == 0.996
X\_test.shape == (1783, 96, 96, 1)

    \end{Verbatim}

    The \texttt{load\_data()} function in \texttt{utils.py} originates from
this excellent
\href{http://danielnouri.org/notes/2014/12/17/using-convolutional-neural-nets-to-detect-facial-keypoints-tutorial/}{blog
post}, which you are \emph{strongly} encouraged to read.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{k}{def} \PY{n+nf}{load\PYZus{}data}\PY{p}{(}\PY{n}{test}\PY{o}{=}\PY{k+kc}{False}\PY{p}{)}\PY{p}{:}
             \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
         \PY{l+s+sd}{    Loads data from FTEST if *test* is True, otherwise from FTRAIN.}
         \PY{l+s+sd}{    Important that the files are in a `data` directory}
         \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}  
             \PY{n}{FTRAIN} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{data/training.csv}\PY{l+s+s1}{\PYZsq{}}
             \PY{n}{FTEST} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{data/test.csv}\PY{l+s+s1}{\PYZsq{}}
             
             \PY{c+c1}{\PYZsh{} Testing data or training data?}
             \PY{n}{fname} \PY{o}{=} \PY{n}{FTEST} \PY{k}{if} \PY{n}{test} \PY{k}{else} \PY{n}{FTRAIN}
             
             \PY{c+c1}{\PYZsh{} Read it\PYZsq{}s csv into a pandas DataFrame}
             \PY{n}{df} \PY{o}{=} \PY{n}{read\PYZus{}csv}\PY{p}{(}\PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{expanduser}\PY{p}{(}\PY{n}{fname}\PY{p}{)}\PY{p}{)}  
         
             \PY{c+c1}{\PYZsh{} The Image column has pixel values separated by space; convert to numpy array:}
             \PY{n}{df}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{n}{df}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{o}{.}\PY{n}{apply}\PY{p}{(}\PY{k}{lambda} \PY{n}{im}\PY{p}{:} \PY{n}{np}\PY{o}{.}\PY{n}{fromstring}\PY{p}{(}\PY{n}{im}\PY{p}{,} \PY{n}{sep}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{} Drop all rows that have missing values in them}
             \PY{n}{df} \PY{o}{=} \PY{n}{df}\PY{o}{.}\PY{n}{dropna}\PY{p}{(}\PY{p}{)}  
             
             \PY{c+c1}{\PYZsh{} Normalize pixel values to [0, 1] via scaling}
             \PY{n}{X} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{vstack}\PY{p}{(}\PY{n}{df}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{o}{.}\PY{n}{values}\PY{p}{)} \PY{o}{/} \PY{l+m+mf}{255.}  
             \PY{n}{X} \PY{o}{=} \PY{n}{X}\PY{o}{.}\PY{n}{astype}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{float32}\PY{p}{)}
             
             \PY{c+c1}{\PYZsh{} Reshape back into images as 96 x 96 x 1}
             \PY{n}{X} \PY{o}{=} \PY{n}{X}\PY{o}{.}\PY{n}{reshape}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{96}\PY{p}{,} \PY{l+m+mi}{96}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)} 
             
             \PY{c+c1}{\PYZsh{} only FTRAIN has target columns}
             \PY{k}{if} \PY{o+ow}{not} \PY{n}{test}\PY{p}{:}  
                 \PY{n}{y} \PY{o}{=} \PY{n}{df}\PY{p}{[}\PY{n}{df}\PY{o}{.}\PY{n}{columns}\PY{p}{[}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}\PY{o}{.}\PY{n}{values}         \PY{c+c1}{\PYZsh{} target coordinates }
                 \PY{n}{y} \PY{o}{=} \PY{p}{(}\PY{n}{y} \PY{o}{\PYZhy{}} \PY{l+m+mi}{48}\PY{p}{)} \PY{o}{/} \PY{l+m+mi}{48}                      \PY{c+c1}{\PYZsh{} scale to [\PYZhy{}1, 1]}
                 \PY{n}{X}\PY{p}{,} \PY{n}{y} \PY{o}{=} \PY{n}{shuffle}\PY{p}{(}\PY{n}{X}\PY{p}{,} \PY{n}{y}\PY{p}{,} \PY{n}{random\PYZus{}state}\PY{o}{=}\PY{l+m+mi}{42}\PY{p}{)}  \PY{c+c1}{\PYZsh{} shuffle train data}
                 \PY{n}{y} \PY{o}{=} \PY{n}{y}\PY{o}{.}\PY{n}{astype}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{float32}\PY{p}{)}               \PY{c+c1}{\PYZsh{} return as float32}
             \PY{k}{else}\PY{p}{:}
                 \PY{n}{y} \PY{o}{=} \PY{k+kc}{None}
         
             \PY{k}{return} \PY{n}{X}\PY{p}{,} \PY{n}{y}
\end{Verbatim}


    Note how the output values - that is, the coordinates of each set of
facial landmarks - have been normalized to take on values in the range
\([-1, 1]\), while the pixel values of each input point (a facial image)
have been normalized to the range \([0,1]\).

Note: the original Kaggle dataset contains some images with several
missing keypoints. For simplicity, the \texttt{load\_data()} function
removes those images with missing labels from the dataset. As an
\textbf{\emph{optional}} extension, you are welcome to amend the
\texttt{load\_data} function to include the incomplete data points!

    \subsubsection{Visualize the Training
Data}\label{visualize-the-training-data}

Execute the code cell below to visualize a subset of the training data.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}24}]:} \PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}
         \PY{o}{\PYZpc{}}\PY{k}{matplotlib} inline
         
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{,}\PY{l+m+mi}{20}\PY{p}{)}\PY{p}{)}
         \PY{n}{fig}\PY{o}{.}\PY{n}{subplots\PYZus{}adjust}\PY{p}{(}\PY{n}{left}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{right}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{bottom}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{top}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{hspace}\PY{o}{=}\PY{l+m+mf}{0.05}\PY{p}{,} \PY{n}{wspace}\PY{o}{=}\PY{l+m+mf}{0.05}\PY{p}{)}
         \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{9}\PY{p}{)}\PY{p}{:}
             \PY{n}{ax} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{i} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{,} \PY{n}{xticks}\PY{o}{=}\PY{p}{[}\PY{p}{]}\PY{p}{,} \PY{n}{yticks}\PY{o}{=}\PY{p}{[}\PY{p}{]}\PY{p}{)}
             \PY{n}{plot\PYZus{}data}\PY{p}{(}\PY{n}{X\PYZus{}train}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{,} \PY{n}{y\PYZus{}train}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{,} \PY{n}{ax}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_55_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    For each training image, there are: * \textbf{2} landmarks per eyebrow
(\textbf{4} total). * \textbf{3} per eye (\textbf{6} total). *
\textbf{4} for the mouth. * \textbf{1} for the tip of the nose.

Review the \texttt{plot\_data()} function in \texttt{utils.py} to
understand how the 30-dimensional training labels in \texttt{y\_train}
are mapped to facial locations, as this function will prove useful for
your pipeline!

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}25}]:} \PY{k}{def} \PY{n+nf}{plot\PYZus{}data}\PY{p}{(}\PY{n}{img}\PY{p}{,} \PY{n}{landmarks}\PY{p}{,} \PY{n}{axis}\PY{p}{)}\PY{p}{:}
             \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
         \PY{l+s+sd}{    Plot image (img), along with normalized facial keypoints (landmarks)}
         \PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
             \PY{c+c1}{\PYZsh{} plot the image}
             \PY{n}{axis}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{squeeze}\PY{p}{(}\PY{n}{img}\PY{p}{)}\PY{p}{,} \PY{n}{cmap}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{gray}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} 
             
             \PY{c+c1}{\PYZsh{} undo the normalization (!?)}
             \PY{n}{landmarks} \PY{o}{=} \PY{n}{landmarks} \PY{o}{*} \PY{l+m+mi}{48} \PY{o}{+} \PY{l+m+mi}{48} 
             
             \PY{c+c1}{\PYZsh{} Plot the keypoints}
             \PY{n}{axis}\PY{o}{.}\PY{n}{scatter}\PY{p}{(}\PY{n}{landmarks}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{:}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} 
                 \PY{n}{landmarks}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} 
                 \PY{n}{marker}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{o}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
                 \PY{n}{c}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{c}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
                 \PY{n}{s}\PY{o}{=}\PY{l+m+mi}{40}\PY{p}{)}
\end{Verbatim}


    \subsubsection{Specify the CNN
Architecture}\label{specify-the-cnn-architecture}

In this section, you will specify a neural network for predicting the
locations of facial keypoints. Use the code cell below to specify the
architecture of your neural network. We have imported some layers that
you may find useful for this task, but if you need to use more Keras
layers, feel free to import them in the cell.

Your network should accept a \(96 \times 96\) grayscale image as input,
and it should output a vector with 30 entries, corresponding to the
predicted (horizontal and vertical) locations of 15 facial keypoints. If
you are not sure where to start, you can find some useful starting
architectures in
\href{http://danielnouri.org/notes/2014/12/17/using-convolutional-neural-nets-to-detect-facial-keypoints-tutorial/}{this
blog}, but you are not permitted to copy any of the architectures that
you find online.

\paragraph{Intution}\label{intution}

We are allowed to talk about
\href{https://adeshpande3.github.io/adeshpande3.github.io/A-Beginner's-Guide-To-Understanding-Convolutional-Neural-Networks-Part-2/}{this
awesome example though}! Let's see what's going on.

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\tightlist
\item
  \textbf{Striding}: Stride controls how the kernel / filter moves
  around the input shape. It's basically the number of squares we can
  move by when we downsample; notice the output for a Stride of 1 vs. a
  Stride of 2: (number of squares we can move by),
\end{enumerate}

\includegraphics{https://adeshpande3.github.io/assets/Stride1.png}
\includegraphics{https://adeshpande3.github.io/assets/Stride2.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{1}
\tightlist
\item
  \textbf{Padding}: As we can see, the output field for a larger stride
  is smaller the bigger we step; sooner or later, we'd have issues
  fitting our kernel onto the squashed images. That's where padding can
  help; if we set our padding to size 2, we add a little buffer room
  about the image that results in a (\texttt{36\ x\ 36\ x\ 2}) shape
  throughought our network, even while we downsample!
\end{enumerate}

\begin{figure}
\centering
\includegraphics{https://adeshpande3.github.io/assets/Pad.png}
\caption{Padding}
\end{figure}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{2}
\tightlist
\item
  \textbf{Convolution}: Therefore, we can describe this convolutional
  layer in a mathematical space. Let's use \texttt{O} is the output
  height/length, \texttt{W} is the input height/length, \texttt{K} is
  the filter size, \texttt{P} is the padding, and \texttt{S} is the
  stride:
\end{enumerate}

\begin{figure}
\centering
\includegraphics{https://adeshpande3.github.io/assets/Output.png}
\caption{}
\end{figure}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{3}
\tightlist
\item
  \textbf{Activation}: Researchers like
  \href{http://www.cs.toronto.edu/~fritz/absps/reluICML.pdf}{Dr. Hinton}
  have discovered out that ReLU layers work far better then most other
  activators, especially with achieving computational efficiency without
  making a significant difference to the accuracy. It also helps to
  alleviate the vanishing gradient problem, which is the issue where the
  lower layers of the network train very slowly because the gradient
  decreases
  \href{https://www.quora.com/What-is-the-vanishing-gradient-problem}{exponentially
  through the layers}. ReLU activation just applies the function
  \(f(x) = max(0, x)\) to all of the values in the input volume, so we
  get 0, an absolute integer, and no negatives.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{http://i2.wp.com/www.jessicayung.com/wp-content/uploads/2017/05/cnn-fletcher-bach.gif?resize=720\%2C530}
\caption{}
\end{figure}

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\setcounter{enumi}{4}
\tightlist
\item
  \textbf{Pooling}: Downsampling post activation! Unlike a typical
  convolution, we are picking standard 'pool' sizes with matching
  strides and padding, and will \textbf{not be generating any trainable
  parameters} that can be affected via ReLU activators and
  backpropogation. All we're getting a smaller / zoomed in image to work
  with; and feed into the next step!
\end{enumerate}

\begin{figure}
\centering
\includegraphics{https://adeshpande3.github.io/assets/MaxPool.png}
\caption{}
\end{figure}

As we convolve, pool, dropout, and repeat, we can train our net to
recognize the features we're looking for; and \textbf{where to put
facial keypoints!} Later, we'll even compare our performance using the
Haar Caascade classifier (and smush 'em together!)

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}26}]:} \PY{c+c1}{\PYZsh{} Import deep learning resources from Keras}
         \PY{k+kn}{from} \PY{n+nn}{keras}\PY{n+nn}{.}\PY{n+nn}{models} \PY{k}{import} \PY{n}{Sequential}
         \PY{k+kn}{from} \PY{n+nn}{keras}\PY{n+nn}{.}\PY{n+nn}{layers} \PY{k}{import} \PY{n}{Convolution2D}\PY{p}{,} \PY{n}{MaxPooling2D}\PY{p}{,} \PY{n}{Dropout}\PY{p}{,} \PY{n}{GlobalAveragePooling2D}\PY{p}{,} \PY{n}{Flatten}\PY{p}{,} \PY{n}{Dense}
         
         \PY{c+c1}{\PYZsh{}\PYZsh{} A Convolutional Neural Network that:}
         \PY{c+c1}{\PYZsh{} * Accept 96x96 pixel graysale images as input.}
         \PY{c+c1}{\PYZsh{} * Use a fully\PYZhy{}connected convolutional neural network to classify facial features.}
         \PY{c+c1}{\PYZsh{} * Output a classification for 30 values (2 for each facial keypoint)}
         
         
         \PY{n}{model} \PY{o}{=} \PY{n}{Sequential}\PY{p}{(}\PY{p}{)}                                    \PY{c+c1}{\PYZsh{} A Linear CNN Layer Stack}
         \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Convolution2D}\PY{p}{(}\PY{n}{filters}\PY{o}{=}\PY{l+m+mi}{32}\PY{p}{,}     
                                 \PY{n}{kernel\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{,} 
                                 \PY{n}{padding}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{valid}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
                                 \PY{n}{activation}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{relu}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
                                 \PY{n}{input\PYZus{}shape}\PY{o}{=}\PY{n}{X\PYZus{}train}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:}\PY{p}{]}\PY{p}{)}\PY{p}{)} \PY{c+c1}{\PYZsh{} Layer 1: 2D Convolution,}
                                                                 \PY{c+c1}{\PYZsh{} 32 Filters (independent kernels)}
                                                                 \PY{c+c1}{\PYZsh{} Using a 3x3 Kernel for the operation,}
                                                                 \PY{c+c1}{\PYZsh{} \PYZsq{}Same\PYZsq{} style padding for uniform image size}
                                                                 \PY{c+c1}{\PYZsh{} Rectified Linear Unit activation,}
                                                                 \PY{c+c1}{\PYZsh{} Shape is the input layer, so use first sample shape}
                             
         \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{MaxPooling2D}\PY{p}{(}\PY{n}{pool\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}                    \PY{c+c1}{\PYZsh{} Layer 2: Pooling}
                                                                 \PY{c+c1}{\PYZsh{} Pool / Average input using 2x2 kernel}
                                                                 \PY{c+c1}{\PYZsh{} Reduce size of kernel (and resulting computation)}
                                                                 \PY{c+c1}{\PYZsh{} Let\PYZsq{}s use increase filters and avoid overfitting}
                     
         \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Dropout}\PY{p}{(}\PY{l+m+mf}{0.2}\PY{p}{)}\PY{p}{)}                                 \PY{c+c1}{\PYZsh{} Layer 3: Dropout}
                                                                 \PY{c+c1}{\PYZsh{} Drop paramaters to avoid overfitting}
                                                                 \PY{c+c1}{\PYZsh{} Somehow even improves performance. Dope.}
         
         \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Convolution2D}\PY{p}{(}\PY{n}{filters}\PY{o}{=}\PY{l+m+mi}{64}\PY{p}{,} 
                                 \PY{n}{kernel\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{,} 
                                 \PY{n}{padding}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{same}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
                                 \PY{n}{activation}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{relu}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}             \PY{c+c1}{\PYZsh{} Layer 4: 2D Convolution,}
                                                                 \PY{c+c1}{\PYZsh{} 128 Filters at 2x2, same padding, ReLU activation}
         
         \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{MaxPooling2D}\PY{p}{(}\PY{n}{pool\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}                    \PY{c+c1}{\PYZsh{} Layer 5: Pooling }
                                                                 \PY{c+c1}{\PYZsh{} Pool / average input using 2x2 kernel}
             
         \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Dropout}\PY{p}{(}\PY{l+m+mf}{0.2}\PY{p}{)}\PY{p}{)}                                 \PY{c+c1}{\PYZsh{} Layer 6: Dropout}
                                                                 \PY{c+c1}{\PYZsh{} Drop 20\PYZpc{} of paramaters }
             
         \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Convolution2D}\PY{p}{(}\PY{n}{filters}\PY{o}{=}\PY{l+m+mi}{128}\PY{p}{,}
                                 \PY{n}{kernel\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{,}
                                  \PY{n}{padding}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{same}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
                                  \PY{n}{activation}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{relu}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}            \PY{c+c1}{\PYZsh{} Layer 7: 2D Convolution,}
                                                                 \PY{c+c1}{\PYZsh{} 128 Filters at 2x2, same padding, ReLU activation}
             
         \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{MaxPooling2D}\PY{p}{(}\PY{n}{pool\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}                    \PY{c+c1}{\PYZsh{} Layer 8: Pooling }
                                                                 \PY{c+c1}{\PYZsh{} Pool / average input using 2x2 kernel}
             
         \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Dropout}\PY{p}{(}\PY{l+m+mf}{0.2}\PY{p}{)}\PY{p}{)}                                 \PY{c+c1}{\PYZsh{} Layer 9: Dropout}
                                                                 \PY{c+c1}{\PYZsh{} Drop 20\PYZpc{} of paramaters }
             
         \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Convolution2D}\PY{p}{(}\PY{n}{filters}\PY{o}{=}\PY{l+m+mi}{256}\PY{p}{,}
                                  \PY{n}{kernel\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{,}
                                  \PY{n}{padding}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{same}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
                                  \PY{n}{activation}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{relu}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}            \PY{c+c1}{\PYZsh{} Layer 10: 2D Convolution,}
                                                                 \PY{c+c1}{\PYZsh{} 256 Filters at 2x2, same padding, ReLU activation}
             
         \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{MaxPooling2D}\PY{p}{(}\PY{n}{pool\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}                    \PY{c+c1}{\PYZsh{} Layer 11: Pooling }
                                                                 \PY{c+c1}{\PYZsh{} Pool / average input using 2x2 kernel}
             
         \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Dropout}\PY{p}{(}\PY{l+m+mf}{0.2}\PY{p}{)}\PY{p}{)}                                 \PY{c+c1}{\PYZsh{} Layer 12: Dropout}
                                                                 \PY{c+c1}{\PYZsh{} Drop 20\PYZpc{} of paramaters }
         \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Convolution2D}\PY{p}{(}\PY{n}{filters}\PY{o}{=}\PY{l+m+mi}{512}\PY{p}{,}
                                  \PY{n}{kernel\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{,}
                                  \PY{n}{padding}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{same}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
                                  \PY{n}{activation}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{relu}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}            \PY{c+c1}{\PYZsh{} Layer 13: 2D Convolution,}
                                                                 \PY{c+c1}{\PYZsh{} 512 Filters! at 2x2, same padding, ReLU activation}
             
         \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{MaxPooling2D}\PY{p}{(}\PY{n}{pool\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}                    \PY{c+c1}{\PYZsh{} Layer 11: Pooling }
                                                                 \PY{c+c1}{\PYZsh{} Pool / average input using 2x2 kernel}
             
         \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Dropout}\PY{p}{(}\PY{l+m+mf}{0.2}\PY{p}{)}\PY{p}{)}                                 \PY{c+c1}{\PYZsh{} Layer 12: Dropout}
                                                                 \PY{c+c1}{\PYZsh{} Drop 20\PYZpc{} of paramaters }
         
         \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{GlobalAveragePooling2D}\PY{p}{(}\PY{p}{)}\PY{p}{)}                     \PY{c+c1}{\PYZsh{} Layer 13: Global 2D Pooling}
                                                                 \PY{c+c1}{\PYZsh{} Global pooling to ensure structural regularization}
                                                                 \PY{c+c1}{\PYZsh{} Evidently good for avoiding overfitting}
                 
         \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Dense}\PY{p}{(}\PY{l+m+mi}{30}\PY{p}{)}\PY{p}{)}                                    \PY{c+c1}{\PYZsh{} Layer 14: Dense Layer}
                                                                 \PY{c+c1}{\PYZsh{} Dense layer for 30 categories / 15 keypoint features}
         
         \PY{n}{model}\PY{o}{.}\PY{n}{summary}\PY{p}{(}\PY{p}{)}                                         \PY{c+c1}{\PYZsh{} Model Summary}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
Layer (type)                 Output Shape              Param \#   
=================================================================
conv2d\_1 (Conv2D)            (None, 94, 94, 32)        320       
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
max\_pooling2d\_1 (MaxPooling2 (None, 47, 47, 32)        0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
dropout\_1 (Dropout)          (None, 47, 47, 32)        0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
conv2d\_2 (Conv2D)            (None, 47, 47, 64)        8256      
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
max\_pooling2d\_2 (MaxPooling2 (None, 23, 23, 64)        0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
dropout\_2 (Dropout)          (None, 23, 23, 64)        0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
conv2d\_3 (Conv2D)            (None, 23, 23, 128)       32896     
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
max\_pooling2d\_3 (MaxPooling2 (None, 11, 11, 128)       0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
dropout\_3 (Dropout)          (None, 11, 11, 128)       0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
conv2d\_4 (Conv2D)            (None, 11, 11, 256)       131328    
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
max\_pooling2d\_4 (MaxPooling2 (None, 5, 5, 256)         0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
dropout\_4 (Dropout)          (None, 5, 5, 256)         0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
conv2d\_5 (Conv2D)            (None, 5, 5, 512)         524800    
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
max\_pooling2d\_5 (MaxPooling2 (None, 2, 2, 512)         0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
dropout\_5 (Dropout)          (None, 2, 2, 512)         0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
global\_average\_pooling2d\_1 ( (None, 512)               0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
dense\_1 (Dense)              (None, 30)                15390     
=================================================================
Total params: 712,990
Trainable params: 712,990
Non-trainable params: 0
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

    \end{Verbatim}

    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Step 6: Compile and Train the
Model}\label{step-6-compile-and-train-the-model}

After specifying your architecture, you'll need to compile and train the
model to detect facial keypoints'

    \subsubsection{Compile and Train the
Model}\label{compile-and-train-the-model}

Use the \texttt{compile()}
\href{https://keras.io/models/sequential/\#sequential-model-methods}{method}
to configure the learning process. Be sure to experiment with your
choice of \href{https://keras.io/optimizers/}{optimizer}; you may have
some ideas about which will work best (\texttt{SGD} vs.
\texttt{RMSprop}, etc), but take the time to empirically verify your
theories.

Use the \texttt{fit()}
\href{https://keras.io/models/sequential/\#sequential-model-methods}{method}
to train the model. Break off a validation set by setting
\texttt{validation\_split=0.2}. Save the returned \texttt{History}
object in the \texttt{history} variable.

Experiment with your model to minimize the validation loss (measured as
mean squared error). A very good model will achieve about 0.0015 loss
(though it's possible to do even better). When you have finished
training,
\href{https://keras.io/getting-started/faq/\#how-can-i-save-a-keras-model}{save
your model} as an HDF5 file with file path \texttt{my\_model.h5}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}27}]:} \PY{k+kn}{from} \PY{n+nn}{keras}\PY{n+nn}{.}\PY{n+nn}{optimizers} \PY{k}{import} \PY{n}{SGD}\PY{p}{,} \PY{n}{RMSprop}\PY{p}{,} \PY{n}{Adagrad}\PY{p}{,} \PY{n}{Adadelta}\PY{p}{,} \PY{n}{Adam}\PY{p}{,} \PY{n}{Adamax}\PY{p}{,} \PY{n}{Nadam}
         \PY{k+kn}{from} \PY{n+nn}{keras}\PY{n+nn}{.}\PY{n+nn}{callbacks} \PY{k}{import} \PY{n}{ModelCheckpoint} 
         
         \PY{c+c1}{\PYZsh{}\PYZsh{} Compile the model}
         \PY{n}{model}\PY{o}{.}\PY{n}{compile}\PY{p}{(}\PY{n}{optimizer}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Adamax}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{loss}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{mean\PYZus{}squared\PYZus{}error}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{metrics}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{accuracy}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{}\PYZsh{} Save the best model as model.h5 (!)}
         \PY{n}{checkpointer} \PY{o}{=} \PY{n}{ModelCheckpoint}\PY{p}{(}\PY{n}{filepath}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{my\PYZus{}model.h5}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} 
                                        \PY{n}{verbose}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{save\PYZus{}best\PYZus{}only}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{}\PYZsh{} Train the model}
         \PY{n}{hist} \PY{o}{=} \PY{n}{model}\PY{o}{.}\PY{n}{fit}\PY{p}{(}\PY{n}{X\PYZus{}train}\PY{p}{,} \PY{n}{y\PYZus{}train}\PY{p}{,} \PY{n}{batch\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{32}\PY{p}{,} \PY{n}{epochs}\PY{o}{=}\PY{l+m+mi}{128}\PY{p}{,} \PY{n}{verbose}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} 
                   \PY{n}{validation\PYZus{}split}\PY{o}{=}\PY{l+m+mf}{0.2}\PY{p}{,} \PY{n}{callbacks}\PY{o}{=}\PY{p}{[}\PY{n}{checkpointer}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Train on 1712 samples, validate on 428 samples
Epoch 1/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0297 - acc: 0.5790Epoch 00001: val\_loss improved from inf to 0.05543, saving model to my\_model.h5
1712/1712 [==============================] - 54s 32ms/step - loss: 0.0295 - acc: 0.5794 - val\_loss: 0.0554 - val\_acc: 0.6963
Epoch 2/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0077 - acc: 0.6498Epoch 00002: val\_loss improved from 0.05543 to 0.04728, saving model to my\_model.h5
1712/1712 [==============================] - 50s 29ms/step - loss: 0.0076 - acc: 0.6513 - val\_loss: 0.0473 - val\_acc: 0.6963
Epoch 3/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0062 - acc: 0.6610Epoch 00003: val\_loss improved from 0.04728 to 0.04686, saving model to my\_model.h5
1712/1712 [==============================] - 44s 26ms/step - loss: 0.0062 - acc: 0.6606 - val\_loss: 0.0469 - val\_acc: 0.6963
Epoch 4/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0059 - acc: 0.6657Epoch 00004: val\_loss improved from 0.04686 to 0.04399, saving model to my\_model.h5
1712/1712 [==============================] - 44s 25ms/step - loss: 0.0058 - acc: 0.6665 - val\_loss: 0.0440 - val\_acc: 0.6963
Epoch 5/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0057 - acc: 0.6775Epoch 00005: val\_loss did not improve
1712/1712 [==============================] - 44s 26ms/step - loss: 0.0057 - acc: 0.6782 - val\_loss: 0.0460 - val\_acc: 0.6963
Epoch 6/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0055 - acc: 0.6751Epoch 00006: val\_loss did not improve
1712/1712 [==============================] - 47s 27ms/step - loss: 0.0055 - acc: 0.6741 - val\_loss: 0.0451 - val\_acc: 0.6963
Epoch 7/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0055 - acc: 0.6733Epoch 00007: val\_loss did not improve
1712/1712 [==============================] - 48s 28ms/step - loss: 0.0055 - acc: 0.6729 - val\_loss: 0.0456 - val\_acc: 0.6963
Epoch 8/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0054 - acc: 0.6804Epoch 00008: val\_loss improved from 0.04399 to 0.04322, saving model to my\_model.h5
1712/1712 [==============================] - 46s 27ms/step - loss: 0.0054 - acc: 0.6799 - val\_loss: 0.0432 - val\_acc: 0.6963
Epoch 9/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0053 - acc: 0.6810Epoch 00009: val\_loss did not improve
1712/1712 [==============================] - 45s 26ms/step - loss: 0.0053 - acc: 0.6805 - val\_loss: 0.0451 - val\_acc: 0.6963
Epoch 10/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0053 - acc: 0.6763Epoch 00010: val\_loss did not improve
1712/1712 [==============================] - 41s 24ms/step - loss: 0.0053 - acc: 0.6752 - val\_loss: 0.0453 - val\_acc: 0.6963
Epoch 11/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0052 - acc: 0.6851Epoch 00011: val\_loss did not improve
1712/1712 [==============================] - 52s 30ms/step - loss: 0.0052 - acc: 0.6852 - val\_loss: 0.0439 - val\_acc: 0.6963
Epoch 12/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0051 - acc: 0.6810Epoch 00012: val\_loss improved from 0.04322 to 0.04033, saving model to my\_model.h5
1712/1712 [==============================] - 53s 31ms/step - loss: 0.0051 - acc: 0.6799 - val\_loss: 0.0403 - val\_acc: 0.6963
Epoch 13/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0050 - acc: 0.6863Epoch 00013: val\_loss improved from 0.04033 to 0.03665, saving model to my\_model.h5
1712/1712 [==============================] - 51s 30ms/step - loss: 0.0050 - acc: 0.6863 - val\_loss: 0.0367 - val\_acc: 0.6963
Epoch 14/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0052 - acc: 0.6934Epoch 00014: val\_loss did not improve
1712/1712 [==============================] - 46s 27ms/step - loss: 0.0052 - acc: 0.6939 - val\_loss: 0.0388 - val\_acc: 0.6963
Epoch 15/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0050 - acc: 0.6934Epoch 00015: val\_loss improved from 0.03665 to 0.03658, saving model to my\_model.h5
1712/1712 [==============================] - 51s 30ms/step - loss: 0.0050 - acc: 0.6951 - val\_loss: 0.0366 - val\_acc: 0.6963
Epoch 16/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0050 - acc: 0.6881Epoch 00016: val\_loss improved from 0.03658 to 0.03465, saving model to my\_model.h5
1712/1712 [==============================] - 55s 32ms/step - loss: 0.0050 - acc: 0.6887 - val\_loss: 0.0347 - val\_acc: 0.6963
Epoch 17/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0049 - acc: 0.6975Epoch 00017: val\_loss improved from 0.03465 to 0.03196, saving model to my\_model.h5
1712/1712 [==============================] - 46s 27ms/step - loss: 0.0049 - acc: 0.6974 - val\_loss: 0.0320 - val\_acc: 0.6986
Epoch 18/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0049 - acc: 0.6993Epoch 00018: val\_loss improved from 0.03196 to 0.03173, saving model to my\_model.h5
1712/1712 [==============================] - 45s 26ms/step - loss: 0.0049 - acc: 0.6974 - val\_loss: 0.0317 - val\_acc: 0.7033
Epoch 19/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0048 - acc: 0.6958Epoch 00019: val\_loss improved from 0.03173 to 0.03039, saving model to my\_model.h5
1712/1712 [==============================] - 44s 26ms/step - loss: 0.0048 - acc: 0.6957 - val\_loss: 0.0304 - val\_acc: 0.6963
Epoch 20/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0048 - acc: 0.6981Epoch 00020: val\_loss improved from 0.03039 to 0.02843, saving model to my\_model.h5
1712/1712 [==============================] - 51s 30ms/step - loss: 0.0048 - acc: 0.6986 - val\_loss: 0.0284 - val\_acc: 0.6986
Epoch 21/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0048 - acc: 0.6910Epoch 00021: val\_loss improved from 0.02843 to 0.02577, saving model to my\_model.h5
1712/1712 [==============================] - 51s 30ms/step - loss: 0.0048 - acc: 0.6922 - val\_loss: 0.0258 - val\_acc: 0.6986
Epoch 22/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0048 - acc: 0.6904Epoch 00022: val\_loss did not improve
1712/1712 [==============================] - 51s 30ms/step - loss: 0.0048 - acc: 0.6904 - val\_loss: 0.0274 - val\_acc: 0.6986
Epoch 23/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0046 - acc: 0.7005Epoch 00023: val\_loss did not improve
1712/1712 [==============================] - 45s 27ms/step - loss: 0.0046 - acc: 0.7004 - val\_loss: 0.0274 - val\_acc: 0.6986
Epoch 24/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0046 - acc: 0.6993Epoch 00024: val\_loss did not improve
1712/1712 [==============================] - 43s 25ms/step - loss: 0.0046 - acc: 0.6992 - val\_loss: 0.0287 - val\_acc: 0.6986
Epoch 25/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0045 - acc: 0.7034Epoch 00025: val\_loss improved from 0.02577 to 0.02317, saving model to my\_model.h5
1712/1712 [==============================] - 51s 30ms/step - loss: 0.0045 - acc: 0.7033 - val\_loss: 0.0232 - val\_acc: 0.6986
Epoch 26/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0044 - acc: 0.6963Epoch 00026: val\_loss improved from 0.02317 to 0.02048, saving model to my\_model.h5
1712/1712 [==============================] - 48s 28ms/step - loss: 0.0044 - acc: 0.6963 - val\_loss: 0.0205 - val\_acc: 0.7033
Epoch 27/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0044 - acc: 0.7040Epoch 00027: val\_loss improved from 0.02048 to 0.01812, saving model to my\_model.h5
1712/1712 [==============================] - 50s 29ms/step - loss: 0.0044 - acc: 0.7015 - val\_loss: 0.0181 - val\_acc: 0.7033
Epoch 28/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0044 - acc: 0.7070Epoch 00028: val\_loss did not improve
1712/1712 [==============================] - 50s 29ms/step - loss: 0.0044 - acc: 0.7062 - val\_loss: 0.0195 - val\_acc: 0.7056
Epoch 29/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0042 - acc: 0.6940Epoch 00029: val\_loss did not improve
1712/1712 [==============================] - 40s 23ms/step - loss: 0.0042 - acc: 0.6945 - val\_loss: 0.0200 - val\_acc: 0.6963
Epoch 30/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0042 - acc: 0.7105Epoch 00030: val\_loss did not improve
1712/1712 [==============================] - 47s 27ms/step - loss: 0.0042 - acc: 0.7114 - val\_loss: 0.0203 - val\_acc: 0.7033
Epoch 31/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0041 - acc: 0.6946Epoch 00031: val\_loss improved from 0.01812 to 0.01719, saving model to my\_model.h5
1712/1712 [==============================] - 46s 27ms/step - loss: 0.0041 - acc: 0.6963 - val\_loss: 0.0172 - val\_acc: 0.7079
Epoch 32/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0039 - acc: 0.6893Epoch 00032: val\_loss improved from 0.01719 to 0.01549, saving model to my\_model.h5
1712/1712 [==============================] - 50s 29ms/step - loss: 0.0039 - acc: 0.6887 - val\_loss: 0.0155 - val\_acc: 0.7033
Epoch 33/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0038 - acc: 0.6993Epoch 00033: val\_loss did not improve
1712/1712 [==============================] - 45s 26ms/step - loss: 0.0038 - acc: 0.6992 - val\_loss: 0.0181 - val\_acc: 0.6986
Epoch 34/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0038 - acc: 0.7046Epoch 00034: val\_loss did not improve
1712/1712 [==============================] - 42s 25ms/step - loss: 0.0038 - acc: 0.7044 - val\_loss: 0.0168 - val\_acc: 0.7056
Epoch 35/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0037 - acc: 0.6987Epoch 00035: val\_loss did not improve
1712/1712 [==============================] - 48s 28ms/step - loss: 0.0037 - acc: 0.6974 - val\_loss: 0.0167 - val\_acc: 0.7009
Epoch 36/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0036 - acc: 0.6952Epoch 00036: val\_loss improved from 0.01549 to 0.01356, saving model to my\_model.h5
1712/1712 [==============================] - 49s 29ms/step - loss: 0.0036 - acc: 0.6957 - val\_loss: 0.0136 - val\_acc: 0.7033
Epoch 37/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0035 - acc: 0.6999Epoch 00037: val\_loss did not improve
1712/1712 [==============================] - 46s 27ms/step - loss: 0.0035 - acc: 0.7009 - val\_loss: 0.0160 - val\_acc: 0.7033
Epoch 38/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0035 - acc: 0.6952Epoch 00038: val\_loss improved from 0.01356 to 0.01248, saving model to my\_model.h5
1712/1712 [==============================] - 43s 25ms/step - loss: 0.0034 - acc: 0.6933 - val\_loss: 0.0125 - val\_acc: 0.7173
Epoch 39/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0036 - acc: 0.7017Epoch 00039: val\_loss did not improve
1712/1712 [==============================] - 47s 27ms/step - loss: 0.0036 - acc: 0.7009 - val\_loss: 0.0129 - val\_acc: 0.7056
Epoch 40/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0033 - acc: 0.7058Epoch 00040: val\_loss improved from 0.01248 to 0.01185, saving model to my\_model.h5
1712/1712 [==============================] - 48s 28ms/step - loss: 0.0033 - acc: 0.7044 - val\_loss: 0.0119 - val\_acc: 0.7150
Epoch 41/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0033 - acc: 0.7058Epoch 00041: val\_loss did not improve
1712/1712 [==============================] - 52s 30ms/step - loss: 0.0033 - acc: 0.7062 - val\_loss: 0.0123 - val\_acc: 0.7009
Epoch 42/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0033 - acc: 0.7034Epoch 00042: val\_loss improved from 0.01185 to 0.00998, saving model to my\_model.h5
1712/1712 [==============================] - 44s 26ms/step - loss: 0.0033 - acc: 0.7039 - val\_loss: 0.0100 - val\_acc: 0.7103
Epoch 43/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0031 - acc: 0.7040Epoch 00043: val\_loss improved from 0.00998 to 0.00873, saving model to my\_model.h5
1712/1712 [==============================] - 48s 28ms/step - loss: 0.0031 - acc: 0.7039 - val\_loss: 0.0087 - val\_acc: 0.7079
Epoch 44/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0031 - acc: 0.6922Epoch 00044: val\_loss did not improve
1712/1712 [==============================] - 46s 27ms/step - loss: 0.0030 - acc: 0.6945 - val\_loss: 0.0092 - val\_acc: 0.7056
Epoch 45/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0030 - acc: 0.7123Epoch 00045: val\_loss did not improve
1712/1712 [==============================] - 49s 29ms/step - loss: 0.0030 - acc: 0.7109 - val\_loss: 0.0093 - val\_acc: 0.7173
Epoch 46/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0029 - acc: 0.7028Epoch 00046: val\_loss improved from 0.00873 to 0.00834, saving model to my\_model.h5
1712/1712 [==============================] - 49s 28ms/step - loss: 0.0029 - acc: 0.7027 - val\_loss: 0.0083 - val\_acc: 0.7150
Epoch 47/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0028 - acc: 0.7005Epoch 00047: val\_loss improved from 0.00834 to 0.00759, saving model to my\_model.h5
1712/1712 [==============================] - 48s 28ms/step - loss: 0.0028 - acc: 0.6998 - val\_loss: 0.0076 - val\_acc: 0.7266
Epoch 48/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0028 - acc: 0.7170Epoch 00048: val\_loss improved from 0.00759 to 0.00639, saving model to my\_model.h5
1712/1712 [==============================] - 46s 27ms/step - loss: 0.0027 - acc: 0.7173 - val\_loss: 0.0064 - val\_acc: 0.7150
Epoch 49/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0027 - acc: 0.6999Epoch 00049: val\_loss did not improve
1712/1712 [==============================] - 51s 30ms/step - loss: 0.0027 - acc: 0.7021 - val\_loss: 0.0069 - val\_acc: 0.7009
Epoch 50/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0027 - acc: 0.7146Epoch 00050: val\_loss did not improve
1712/1712 [==============================] - 50s 29ms/step - loss: 0.0027 - acc: 0.7138 - val\_loss: 0.0072 - val\_acc: 0.6963
Epoch 51/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0026 - acc: 0.7129Epoch 00051: val\_loss improved from 0.00639 to 0.00426, saving model to my\_model.h5
1712/1712 [==============================] - 49s 28ms/step - loss: 0.0026 - acc: 0.7138 - val\_loss: 0.0043 - val\_acc: 0.7266
Epoch 52/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0027 - acc: 0.7129Epoch 00052: val\_loss did not improve
1712/1712 [==============================] - 45s 26ms/step - loss: 0.0027 - acc: 0.7144 - val\_loss: 0.0055 - val\_acc: 0.7079
Epoch 53/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0025 - acc: 0.7158Epoch 00053: val\_loss did not improve
1712/1712 [==============================] - 42s 24ms/step - loss: 0.0025 - acc: 0.7150 - val\_loss: 0.0050 - val\_acc: 0.7196
Epoch 54/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0024 - acc: 0.7329Epoch 00054: val\_loss did not improve
1712/1712 [==============================] - 43s 25ms/step - loss: 0.0024 - acc: 0.7336 - val\_loss: 0.0046 - val\_acc: 0.7360
Epoch 55/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0023 - acc: 0.7140Epoch 00055: val\_loss improved from 0.00426 to 0.00404, saving model to my\_model.h5
1712/1712 [==============================] - 49s 29ms/step - loss: 0.0023 - acc: 0.7144 - val\_loss: 0.0040 - val\_acc: 0.7336
Epoch 56/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0023 - acc: 0.7388Epoch 00056: val\_loss improved from 0.00404 to 0.00398, saving model to my\_model.h5
1712/1712 [==============================] - 57s 33ms/step - loss: 0.0023 - acc: 0.7377 - val\_loss: 0.0040 - val\_acc: 0.7266
Epoch 57/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0022 - acc: 0.7211Epoch 00057: val\_loss improved from 0.00398 to 0.00370, saving model to my\_model.h5
1712/1712 [==============================] - 48s 28ms/step - loss: 0.0022 - acc: 0.7202 - val\_loss: 0.0037 - val\_acc: 0.7336
Epoch 58/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0022 - acc: 0.7252Epoch 00058: val\_loss did not improve
1712/1712 [==============================] - 41s 24ms/step - loss: 0.0022 - acc: 0.7255 - val\_loss: 0.0038 - val\_acc: 0.7220
Epoch 59/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0021 - acc: 0.7364Epoch 00059: val\_loss did not improve
1712/1712 [==============================] - 44s 26ms/step - loss: 0.0021 - acc: 0.7354 - val\_loss: 0.0042 - val\_acc: 0.7360
Epoch 60/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0021 - acc: 0.7294Epoch 00060: val\_loss improved from 0.00370 to 0.00351, saving model to my\_model.h5
1712/1712 [==============================] - 49s 29ms/step - loss: 0.0021 - acc: 0.7284 - val\_loss: 0.0035 - val\_acc: 0.7196
Epoch 61/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0020 - acc: 0.7429Epoch 00061: val\_loss improved from 0.00351 to 0.00297, saving model to my\_model.h5
1712/1712 [==============================] - 52s 30ms/step - loss: 0.0020 - acc: 0.7442 - val\_loss: 0.0030 - val\_acc: 0.7360
Epoch 62/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0020 - acc: 0.7364Epoch 00062: val\_loss improved from 0.00297 to 0.00247, saving model to my\_model.h5
1712/1712 [==============================] - 42s 25ms/step - loss: 0.0020 - acc: 0.7371 - val\_loss: 0.0025 - val\_acc: 0.7407
Epoch 63/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0019 - acc: 0.7400Epoch 00063: val\_loss did not improve
1712/1712 [==============================] - 41s 24ms/step - loss: 0.0019 - acc: 0.7401 - val\_loss: 0.0028 - val\_acc: 0.7290
Epoch 64/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0019 - acc: 0.7435Epoch 00064: val\_loss did not improve
1712/1712 [==============================] - 43s 25ms/step - loss: 0.0019 - acc: 0.7447 - val\_loss: 0.0030 - val\_acc: 0.7430
Epoch 65/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0019 - acc: 0.7482Epoch 00065: val\_loss did not improve
1712/1712 [==============================] - 46s 27ms/step - loss: 0.0019 - acc: 0.7488 - val\_loss: 0.0030 - val\_acc: 0.7664
Epoch 66/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0019 - acc: 0.7429Epoch 00066: val\_loss improved from 0.00247 to 0.00223, saving model to my\_model.h5
1712/1712 [==============================] - 45s 26ms/step - loss: 0.0019 - acc: 0.7424 - val\_loss: 0.0022 - val\_acc: 0.7477
Epoch 67/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0018 - acc: 0.7506Epoch 00067: val\_loss improved from 0.00223 to 0.00219, saving model to my\_model.h5
1712/1712 [==============================] - 49s 29ms/step - loss: 0.0018 - acc: 0.7488 - val\_loss: 0.0022 - val\_acc: 0.7477
Epoch 68/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0018 - acc: 0.7465Epoch 00068: val\_loss did not improve
1712/1712 [==============================] - 40s 24ms/step - loss: 0.0017 - acc: 0.7471 - val\_loss: 0.0026 - val\_acc: 0.7477
Epoch 69/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0017 - acc: 0.7577Epoch 00069: val\_loss did not improve
1712/1712 [==============================] - 45s 26ms/step - loss: 0.0017 - acc: 0.7570 - val\_loss: 0.0023 - val\_acc: 0.7383
Epoch 70/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0017 - acc: 0.7529Epoch 00070: val\_loss did not improve
1712/1712 [==============================] - 61s 36ms/step - loss: 0.0017 - acc: 0.7541 - val\_loss: 0.0025 - val\_acc: 0.7547
Epoch 71/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0017 - acc: 0.7618Epoch 00071: val\_loss did not improve
1712/1712 [==============================] - 40s 23ms/step - loss: 0.0017 - acc: 0.7617 - val\_loss: 0.0023 - val\_acc: 0.7734
Epoch 72/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0016 - acc: 0.7718Epoch 00072: val\_loss improved from 0.00219 to 0.00194, saving model to my\_model.h5
1712/1712 [==============================] - 41s 24ms/step - loss: 0.0016 - acc: 0.7704 - val\_loss: 0.0019 - val\_acc: 0.7477
Epoch 73/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0016 - acc: 0.7565Epoch 00073: val\_loss did not improve
1712/1712 [==============================] - 45s 26ms/step - loss: 0.0016 - acc: 0.7558 - val\_loss: 0.0025 - val\_acc: 0.7570
Epoch 74/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0015 - acc: 0.7653Epoch 00074: val\_loss did not improve
1712/1712 [==============================] - 41s 24ms/step - loss: 0.0015 - acc: 0.7669 - val\_loss: 0.0025 - val\_acc: 0.7523
Epoch 75/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0015 - acc: 0.7547Epoch 00075: val\_loss improved from 0.00194 to 0.00183, saving model to my\_model.h5
1712/1712 [==============================] - 47s 28ms/step - loss: 0.0015 - acc: 0.7558 - val\_loss: 0.0018 - val\_acc: 0.7570
Epoch 76/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0015 - acc: 0.7830Epoch 00076: val\_loss improved from 0.00183 to 0.00181, saving model to my\_model.h5
1712/1712 [==============================] - 49s 29ms/step - loss: 0.0015 - acc: 0.7827 - val\_loss: 0.0018 - val\_acc: 0.7640
Epoch 77/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0014 - acc: 0.7636Epoch 00077: val\_loss improved from 0.00181 to 0.00164, saving model to my\_model.h5
1712/1712 [==============================] - 39s 23ms/step - loss: 0.0014 - acc: 0.7629 - val\_loss: 0.0016 - val\_acc: 0.7570
Epoch 78/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0015 - acc: 0.7647Epoch 00078: val\_loss did not improve
1712/1712 [==============================] - 41s 24ms/step - loss: 0.0015 - acc: 0.7664 - val\_loss: 0.0018 - val\_acc: 0.7593
Epoch 79/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0014 - acc: 0.7683Epoch 00079: val\_loss did not improve
1712/1712 [==============================] - 38s 22ms/step - loss: 0.0014 - acc: 0.7669 - val\_loss: 0.0017 - val\_acc: 0.7523
Epoch 80/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0013 - acc: 0.7754Epoch 00080: val\_loss did not improve
1712/1712 [==============================] - 48s 28ms/step - loss: 0.0013 - acc: 0.7757 - val\_loss: 0.0020 - val\_acc: 0.7547
Epoch 81/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0014 - acc: 0.7836Epoch 00081: val\_loss did not improve
1712/1712 [==============================] - 45s 26ms/step - loss: 0.0014 - acc: 0.7850 - val\_loss: 0.0024 - val\_acc: 0.7664
Epoch 82/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0013 - acc: 0.7818Epoch 00082: val\_loss did not improve
1712/1712 [==============================] - 42s 25ms/step - loss: 0.0013 - acc: 0.7804 - val\_loss: 0.0019 - val\_acc: 0.7617
Epoch 83/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0013 - acc: 0.7954Epoch 00083: val\_loss did not improve
1712/1712 [==============================] - 38s 22ms/step - loss: 0.0013 - acc: 0.7967 - val\_loss: 0.0017 - val\_acc: 0.7617
Epoch 84/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0013 - acc: 0.7848Epoch 00084: val\_loss did not improve
1712/1712 [==============================] - 38s 22ms/step - loss: 0.0013 - acc: 0.7845 - val\_loss: 0.0017 - val\_acc: 0.7687
Epoch 85/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0012 - acc: 0.7854Epoch 00085: val\_loss did not improve
1712/1712 [==============================] - 44s 26ms/step - loss: 0.0012 - acc: 0.7856 - val\_loss: 0.0018 - val\_acc: 0.7617
Epoch 86/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0012 - acc: 0.7824Epoch 00086: val\_loss did not improve
1712/1712 [==============================] - 45s 26ms/step - loss: 0.0012 - acc: 0.7827 - val\_loss: 0.0017 - val\_acc: 0.7523
Epoch 87/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0012 - acc: 0.8007Epoch 00087: val\_loss improved from 0.00164 to 0.00162, saving model to my\_model.h5
1712/1712 [==============================] - 43s 25ms/step - loss: 0.0012 - acc: 0.8014 - val\_loss: 0.0016 - val\_acc: 0.7640
Epoch 88/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0012 - acc: 0.7901Epoch 00088: val\_loss did not improve
1712/1712 [==============================] - 45s 26ms/step - loss: 0.0012 - acc: 0.7909 - val\_loss: 0.0018 - val\_acc: 0.7523
Epoch 89/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0011 - acc: 0.7989Epoch 00089: val\_loss improved from 0.00162 to 0.00141, saving model to my\_model.h5
1712/1712 [==============================] - 39s 23ms/step - loss: 0.0011 - acc: 0.7991 - val\_loss: 0.0014 - val\_acc: 0.7804
Epoch 90/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0011 - acc: 0.7936Epoch 00090: val\_loss did not improve
1712/1712 [==============================] - 43s 25ms/step - loss: 0.0011 - acc: 0.7932 - val\_loss: 0.0015 - val\_acc: 0.7710
Epoch 91/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0011 - acc: 0.7925Epoch 00091: val\_loss did not improve
1712/1712 [==============================] - 48s 28ms/step - loss: 0.0011 - acc: 0.7932 - val\_loss: 0.0017 - val\_acc: 0.7617
Epoch 92/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0011 - acc: 0.7925Epoch 00092: val\_loss did not improve
1712/1712 [==============================] - 44s 26ms/step - loss: 0.0011 - acc: 0.7932 - val\_loss: 0.0018 - val\_acc: 0.7593
Epoch 93/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0011 - acc: 0.8031Epoch 00093: val\_loss did not improve
1712/1712 [==============================] - 38s 22ms/step - loss: 0.0011 - acc: 0.8020 - val\_loss: 0.0014 - val\_acc: 0.7664
Epoch 94/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0011 - acc: 0.8025Epoch 00094: val\_loss did not improve
1712/1712 [==============================] - 38s 22ms/step - loss: 0.0011 - acc: 0.8020 - val\_loss: 0.0017 - val\_acc: 0.7757
Epoch 95/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0010 - acc: 0.7936Epoch 00095: val\_loss did not improve
1712/1712 [==============================] - 37s 22ms/step - loss: 0.0010 - acc: 0.7926 - val\_loss: 0.0015 - val\_acc: 0.7664
Epoch 96/128
1696/1712 [============================>.] - ETA: 0s - loss: 9.9076e-04 - acc: 0.7972Epoch 00096: val\_loss did not improve
1712/1712 [==============================] - 44s 26ms/step - loss: 9.9107e-04 - acc: 0.7944 - val\_loss: 0.0015 - val\_acc: 0.7734
Epoch 97/128
1696/1712 [============================>.] - ETA: 0s - loss: 0.0010 - acc: 0.8037Epoch 00097: val\_loss did not improve
1712/1712 [==============================] - 46s 27ms/step - loss: 0.0010 - acc: 0.8055 - val\_loss: 0.0016 - val\_acc: 0.7780
Epoch 98/128
1696/1712 [============================>.] - ETA: 0s - loss: 9.7826e-04 - acc: 0.7966Epoch 00098: val\_loss did not improve
1712/1712 [==============================] - 44s 26ms/step - loss: 9.7915e-04 - acc: 0.7973 - val\_loss: 0.0015 - val\_acc: 0.7617
Epoch 99/128
1696/1712 [============================>.] - ETA: 0s - loss: 9.8913e-04 - acc: 0.8078Epoch 00099: val\_loss did not improve
1712/1712 [==============================] - 39s 23ms/step - loss: 9.8738e-04 - acc: 0.8072 - val\_loss: 0.0020 - val\_acc: 0.7850
Epoch 100/128
1696/1712 [============================>.] - ETA: 0s - loss: 9.5465e-04 - acc: 0.8172Epoch 00100: val\_loss improved from 0.00141 to 0.00132, saving model to my\_model.h5
1712/1712 [==============================] - 38s 22ms/step - loss: 9.5700e-04 - acc: 0.8154 - val\_loss: 0.0013 - val\_acc: 0.7710
Epoch 101/128
1696/1712 [============================>.] - ETA: 0s - loss: 9.2048e-04 - acc: 0.8042Epoch 00101: val\_loss did not improve
1712/1712 [==============================] - 46s 27ms/step - loss: 9.2040e-04 - acc: 0.8049 - val\_loss: 0.0015 - val\_acc: 0.7640
Epoch 102/128
1696/1712 [============================>.] - ETA: 0s - loss: 8.9972e-04 - acc: 0.8060Epoch 00102: val\_loss did not improve
1712/1712 [==============================] - 47s 27ms/step - loss: 9.0054e-04 - acc: 0.8061 - val\_loss: 0.0014 - val\_acc: 0.7874
Epoch 103/128
1696/1712 [============================>.] - ETA: 0s - loss: 9.0669e-04 - acc: 0.8137Epoch 00103: val\_loss did not improve
1712/1712 [==============================] - 44s 26ms/step - loss: 9.0379e-04 - acc: 0.8143 - val\_loss: 0.0015 - val\_acc: 0.7804
Epoch 104/128
1696/1712 [============================>.] - ETA: 0s - loss: 8.8964e-04 - acc: 0.8184Epoch 00104: val\_loss improved from 0.00132 to 0.00130, saving model to my\_model.h5
1712/1712 [==============================] - 41s 24ms/step - loss: 8.9157e-04 - acc: 0.8178 - val\_loss: 0.0013 - val\_acc: 0.7780
Epoch 105/128
1696/1712 [============================>.] - ETA: 0s - loss: 8.6426e-04 - acc: 0.8172Epoch 00105: val\_loss did not improve
1712/1712 [==============================] - 42s 24ms/step - loss: 8.6502e-04 - acc: 0.8178 - val\_loss: 0.0013 - val\_acc: 0.7780
Epoch 106/128
1696/1712 [============================>.] - ETA: 0s - loss: 8.4235e-04 - acc: 0.8137Epoch 00106: val\_loss did not improve
1712/1712 [==============================] - 39s 23ms/step - loss: 8.4166e-04 - acc: 0.8143 - val\_loss: 0.0016 - val\_acc: 0.7804
Epoch 107/128
1696/1712 [============================>.] - ETA: 0s - loss: 8.4222e-04 - acc: 0.8131Epoch 00107: val\_loss improved from 0.00130 to 0.00119, saving model to my\_model.h5
1712/1712 [==============================] - 46s 27ms/step - loss: 8.4065e-04 - acc: 0.8137 - val\_loss: 0.0012 - val\_acc: 0.7921
Epoch 108/128
1696/1712 [============================>.] - ETA: 0s - loss: 8.4439e-04 - acc: 0.8202Epoch 00108: val\_loss did not improve
1712/1712 [==============================] - 49s 28ms/step - loss: 8.4280e-04 - acc: 0.8207 - val\_loss: 0.0015 - val\_acc: 0.7827
Epoch 109/128
1696/1712 [============================>.] - ETA: 0s - loss: 8.9582e-04 - acc: 0.8202Epoch 00109: val\_loss did not improve
1712/1712 [==============================] - 39s 23ms/step - loss: 8.9742e-04 - acc: 0.8195 - val\_loss: 0.0014 - val\_acc: 0.7804
Epoch 110/128
1696/1712 [============================>.] - ETA: 0s - loss: 8.3077e-04 - acc: 0.8284Epoch 00110: val\_loss did not improve
1712/1712 [==============================] - 42s 25ms/step - loss: 8.3249e-04 - acc: 0.8277 - val\_loss: 0.0014 - val\_acc: 0.7967
Epoch 111/128
1696/1712 [============================>.] - ETA: 0s - loss: 7.8855e-04 - acc: 0.8308Epoch 00111: val\_loss did not improve
1712/1712 [==============================] - 40s 23ms/step - loss: 7.8728e-04 - acc: 0.8312 - val\_loss: 0.0012 - val\_acc: 0.7967
Epoch 112/128
1696/1712 [============================>.] - ETA: 0s - loss: 7.7478e-04 - acc: 0.8373Epoch 00112: val\_loss did not improve
1712/1712 [==============================] - 44s 26ms/step - loss: 7.7635e-04 - acc: 0.8370 - val\_loss: 0.0013 - val\_acc: 0.7944
Epoch 113/128
1696/1712 [============================>.] - ETA: 0s - loss: 7.7066e-04 - acc: 0.8320Epoch 00113: val\_loss did not improve
1712/1712 [==============================] - 45s 26ms/step - loss: 7.7173e-04 - acc: 0.8324 - val\_loss: 0.0015 - val\_acc: 0.7921
Epoch 114/128
1696/1712 [============================>.] - ETA: 0s - loss: 7.9540e-04 - acc: 0.8320Epoch 00114: val\_loss did not improve
1712/1712 [==============================] - 42s 24ms/step - loss: 7.9406e-04 - acc: 0.8306 - val\_loss: 0.0013 - val\_acc: 0.7850
Epoch 115/128
1696/1712 [============================>.] - ETA: 0s - loss: 7.4436e-04 - acc: 0.8302Epoch 00115: val\_loss improved from 0.00119 to 0.00118, saving model to my\_model.h5
1712/1712 [==============================] - 35s 21ms/step - loss: 7.4535e-04 - acc: 0.8300 - val\_loss: 0.0012 - val\_acc: 0.7921
Epoch 116/128
1696/1712 [============================>.] - ETA: 0s - loss: 7.2267e-04 - acc: 0.8290Epoch 00116: val\_loss did not improve
1712/1712 [==============================] - 40s 24ms/step - loss: 7.2530e-04 - acc: 0.8283 - val\_loss: 0.0014 - val\_acc: 0.7874
Epoch 117/128
1696/1712 [============================>.] - ETA: 0s - loss: 7.5779e-04 - acc: 0.8308Epoch 00117: val\_loss improved from 0.00118 to 0.00118, saving model to my\_model.h5
1712/1712 [==============================] - 40s 24ms/step - loss: 7.5757e-04 - acc: 0.8306 - val\_loss: 0.0012 - val\_acc: 0.8037
Epoch 118/128
1696/1712 [============================>.] - ETA: 0s - loss: 7.3144e-04 - acc: 0.8267Epoch 00118: val\_loss did not improve
1712/1712 [==============================] - 48s 28ms/step - loss: 7.3214e-04 - acc: 0.8265 - val\_loss: 0.0014 - val\_acc: 0.8014
Epoch 119/128
1696/1712 [============================>.] - ETA: 0s - loss: 7.1267e-04 - acc: 0.8396Epoch 00119: val\_loss did not improve
1712/1712 [==============================] - 46s 27ms/step - loss: 7.1607e-04 - acc: 0.8394 - val\_loss: 0.0013 - val\_acc: 0.7944
Epoch 120/128
1696/1712 [============================>.] - ETA: 0s - loss: 7.1071e-04 - acc: 0.8278Epoch 00120: val\_loss did not improve
1712/1712 [==============================] - 41s 24ms/step - loss: 7.1528e-04 - acc: 0.8294 - val\_loss: 0.0015 - val\_acc: 0.8037
Epoch 121/128
1696/1712 [============================>.] - ETA: 0s - loss: 7.1939e-04 - acc: 0.8343Epoch 00121: val\_loss did not improve
1712/1712 [==============================] - 40s 23ms/step - loss: 7.2128e-04 - acc: 0.8347 - val\_loss: 0.0015 - val\_acc: 0.7874
Epoch 122/128
1696/1712 [============================>.] - ETA: 0s - loss: 7.0496e-04 - acc: 0.8278Epoch 00122: val\_loss did not improve
1712/1712 [==============================] - 41s 24ms/step - loss: 7.0470e-04 - acc: 0.8277 - val\_loss: 0.0013 - val\_acc: 0.7944
Epoch 123/128
1696/1712 [============================>.] - ETA: 0s - loss: 7.0144e-04 - acc: 0.8272Epoch 00123: val\_loss did not improve
1712/1712 [==============================] - 45s 26ms/step - loss: 7.0304e-04 - acc: 0.8248 - val\_loss: 0.0014 - val\_acc: 0.7827
Epoch 124/128
1696/1712 [============================>.] - ETA: 0s - loss: 6.8136e-04 - acc: 0.8349Epoch 00124: val\_loss did not improve
1712/1712 [==============================] - 49s 29ms/step - loss: 6.8147e-04 - acc: 0.8353 - val\_loss: 0.0014 - val\_acc: 0.8037
Epoch 125/128
1696/1712 [============================>.] - ETA: 0s - loss: 6.9393e-04 - acc: 0.8284Epoch 00125: val\_loss did not improve
1712/1712 [==============================] - 42s 25ms/step - loss: 6.9174e-04 - acc: 0.8300 - val\_loss: 0.0014 - val\_acc: 0.8014
Epoch 126/128
1696/1712 [============================>.] - ETA: 0s - loss: 6.7742e-04 - acc: 0.8384Epoch 00126: val\_loss improved from 0.00118 to 0.00116, saving model to my\_model.h5
1712/1712 [==============================] - 41s 24ms/step - loss: 6.7665e-04 - acc: 0.8382 - val\_loss: 0.0012 - val\_acc: 0.7967
Epoch 127/128
1696/1712 [============================>.] - ETA: 0s - loss: 6.5515e-04 - acc: 0.8414Epoch 00127: val\_loss improved from 0.00116 to 0.00115, saving model to my\_model.h5
1712/1712 [==============================] - 43s 25ms/step - loss: 6.5452e-04 - acc: 0.8429 - val\_loss: 0.0011 - val\_acc: 0.8084
Epoch 128/128
1696/1712 [============================>.] - ETA: 0s - loss: 6.5983e-04 - acc: 0.8573Epoch 00128: val\_loss did not improve
1712/1712 [==============================] - 52s 30ms/step - loss: 6.6075e-04 - acc: 0.8575 - val\_loss: 0.0013 - val\_acc: 0.7967

    \end{Verbatim}

    Quick reference point when you're attempting to run the code above; I
had to leave this computer on for at least half a day to roll the loss
and accuracy to these levels. I literally had to restart the kernel to
get my mode!

The good news is the \texttt{save()} function in our epoch step ensures
we always save the best available model. This is where stuff like
TensorFlow and Keras really shine; multiple layers of well thought out
abstractions (in an occasionally opinionated syntax.)

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}61}]:} \PY{k+kn}{from} \PY{n+nn}{keras}\PY{n+nn}{.}\PY{n+nn}{models} \PY{k}{import} \PY{n}{load\PYZus{}model}
         
         \PY{c+c1}{\PYZsh{} Loading the best model found}
         \PY{n}{model} \PY{o}{=} \PY{n}{load\PYZus{}model}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{my\PYZus{}model.h5}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Step 7: Visualize the Loss and Test
Predictions}\label{step-7-visualize-the-loss-and-test-predictions}

    \subsubsection{Answer a few questions and visualize the
loss}\label{answer-a-few-questions-and-visualize-the-loss}

\textbf{Question 1:} Outline the steps you took to get to your final
neural network architecture and your reasoning at each step.

\textbf{Answer:} This structure is a fairly standard CNN skeleton,
lifted and retrofit from some earlier work. I'd like to discuss the
\texttt{convolution(),\ pooling(),\ dropout()} substack, because it's
role seems crucial to our performance and
\href{http://arxiv.org/pdf/1312.4400.pdf}{explored much more thoroughly
in this paper}). To poorly snynthesize, I feel it to give us 4 things: *
\textbf{Scaling Filters}: Without pooling and dropout, the number of
trainable parameters would get out of control too fast; we're already at
712K trainable values, and thats already with 20\% decrease in
connectivity every stage. * \textbf{Kernel Pooling}: Reducing images to
smaller, denser vectors seems counterintuitive, but the intuition seems
very similar to the Gaussian blurring we used for edge detection
earlier; by blurring or otherwise transforming a region, we drop local
structure for global structures. * \textbf{Cascading Convolution}: Just
like the earlier cascade filter, we are best served by analyzing the
existence of 'feature groups', which is kind of what this CNN is
stumbling upon, especially by using the well labelled keypoint data to
correct via backprop. This idealogy has been further evolved using
\href{https://medium.com/ai\%C2\%B3-theory-practice-business/understanding-hintons-capsule-networks-part-ii-how-capsules-work-153b6ade9f66}{Capsule
Networks} from the OG himself,
\href{http://www.cs.toronto.edu/~hinton/}{George Hinton}. *
\textbf{Dropout}: Dropout is a remarkably useful tool for preventing
overfitting. I have still to understand why fewer connections yield such
better results, though a little noise seems to great improve the
performance. For some reason or another, gradient descent goes smoother
on slightly rougher, unknown terrain.

After all those layers I we added a \texttt{globalaveragepool()} of
\href{https://keras.io/applications/\#resnet50}{ResNet-50} fame. It aims
to enforce global feature detection, further preventing overfitting,
before a final \texttt{dense()} layer to classify our feature detection
output via 30 densly connected linear classifiers.

\textbf{Question 2:} Defend your choice of optimizer. Which optimizers
did you test, and how did you determine which worked best?

\textbf{Answer:} The
\href{https://arxiv.org/pdf/1412.6980.pdf}{\texttt{Adamax}} is an
evolution of the \texttt{Adam} optimizer, which computes individual
adaptive learning rates for different parameters from estimates of first
and second moments of the gradients; hence it's name, \emph{Ada}ptive
\emph{M}oment estimation. It sounds like just bias-free \texttt{RMSProp}
estimation, which is more cost effective. \texttt{Adamax} is a further
expansion of the \texttt{Adam} optimizer, whose update rule for
individual weights is to scale their gradients inversely proportional to
a (scaled) \(L^2\) norm of their current and past gradients. If we
generalize this \(L^2\) norm-based update rule to an \(L^p\) norm based
update rule, we run into variants that become numerically unstable for
large \(p\). However, a special case emerges for just the limit, i.e.
\(p → ∞\); a surprisingly simple and stable algorithm emerges! Frankly
speaking, some of the math past this point is well beyond me, but as a
new and interesting optimizer I was eager to test it in the field.

Use the code cell below to plot the training and validation loss of your
neural network. You may find
\href{http://machinelearningmastery.com/display-deep-learning-model-training-history-in-keras/}{this
resource} useful.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}62}]:} \PY{c+c1}{\PYZsh{}\PYZsh{} Visualize the training and validation loss of your neural network }
         
         \PY{c+c1}{\PYZsh{} Available historical data}
         \PY{c+c1}{\PYZsh{} print(hist.history.keys())}
         
         \PY{c+c1}{\PYZsh{} Accuracy History}
         \PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{hist}\PY{o}{.}\PY{n}{history}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{acc}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{hist}\PY{o}{.}\PY{n}{history}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{val\PYZus{}acc}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Model Accuracy}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{ylabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{accuracy}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{epoch}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{legend}\PY{p}{(}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{train}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{test}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{n}{loc}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{upper left}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Loss History}
         \PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{hist}\PY{o}{.}\PY{n}{history}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{loss}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{hist}\PY{o}{.}\PY{n}{history}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{val\PYZus{}loss}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Model Loss}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{ylabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{loss}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{epoch}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{legend}\PY{p}{(}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{train}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{test}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{n}{loc}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{upper left}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_67_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_67_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \textbf{Question 3:} Do you notice any evidence of overfitting or
underfitting in the above plot? If so, what steps have you taken to
improve your model? Note that slight overfitting or underfitting will
not hurt your chances of a successful submission, as long as you have
attempted some solutions towards improving your model (such as
\emph{regularization, dropout, increased/decreased number of layers,
etc}).

\textbf{Answer:} In past projects with fewer layers and no dropout, I'd
achieve some pretty horific losses. I'd hope that the more conservative,
\texttt{dropout()} intensive architecture with the new \texttt{Adamax}
optimizer should yield much better results. I also saw an increase in
performance when I used that sub-network 4 times instead of just 3. I'd
be open to any suggestions! Also, earlier runs of the training had a
very close train and test loss, but it seems here that were are
beginning to overfit quite severely to our training data. At least we're
only talking about loss around 0.0010.

    \subsubsection{Visualize a Subset of the Test
Predictions}\label{visualize-a-subset-of-the-test-predictions}

Execute the code cell below to visualize your model's predicted
keypoints on a subset of the testing images.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}63}]:} \PY{n}{y\PYZus{}test} \PY{o}{=} \PY{n}{model}\PY{o}{.}\PY{n}{predict}\PY{p}{(}\PY{n}{X\PYZus{}test}\PY{p}{)}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{,}\PY{l+m+mi}{20}\PY{p}{)}\PY{p}{)}
         \PY{n}{fig}\PY{o}{.}\PY{n}{subplots\PYZus{}adjust}\PY{p}{(}\PY{n}{left}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{right}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{bottom}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{top}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{hspace}\PY{o}{=}\PY{l+m+mf}{0.05}\PY{p}{,} \PY{n}{wspace}\PY{o}{=}\PY{l+m+mf}{0.05}\PY{p}{)}
         \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{9}\PY{p}{)}\PY{p}{:}
             \PY{n}{ax} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{i} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{,} \PY{n}{xticks}\PY{o}{=}\PY{p}{[}\PY{p}{]}\PY{p}{,} \PY{n}{yticks}\PY{o}{=}\PY{p}{[}\PY{p}{]}\PY{p}{)}
             \PY{n}{plot\PYZus{}data}\PY{p}{(}\PY{n}{X\PYZus{}test}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{,} \PY{n}{y\PYZus{}test}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{,} \PY{n}{ax}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_70_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Step 8: Complete the
pipeline}\label{step-8-complete-the-pipeline}

With the work you did in Sections 1 and 2 of this notebook, along with
your freshly trained facial keypoint detector, you can now complete the
full pipeline. That is given a color image containing a person or
persons you can now

\begin{itemize}
\tightlist
\item
  Detect the faces in this image automatically using OpenCV
\item
  Predict the facial keypoints in each face detected in the image
\item
  Paint predicted keypoints on each face detected
\end{itemize}

In this Subsection you will do just this!

    \subsubsection{Facial Keypoints
Detector}\label{facial-keypoints-detector}

Finally, let's use the OpenCV face detection functionality we built in
previous Sections to expand the functionality of your keypoints detector
to color images with arbitrary size. Our function should perform the
following steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Accept a color image.
\item
  Convert the image to grayscale.
\item
  Detect and crop the face contained in the image.
\item
  Locate the facial keypoints in the cropped image.
\item
  Overlay the facial keypoints in the original (color, uncropped) image.
\end{enumerate}

\textbf{Note}: step 4 can be the trickiest because remember your
convolutional network is only trained to detect facial keypoints in
\(96 \times 96\) grayscale images where each pixel was normalized to lie
in the interval \([0,1]\), and remember that each facial keypoint was
normalized during training to the interval \([-1,1]\). This means -
practically speaking - to paint detected keypoints onto a test face you
need to perform this same pre-processing to your candidate face - that
is after detecting it you should resize it to \(96 \times 96\) and
normalize its values before feeding it into your facial keypoint
detector. To be shown correctly on the original image the output
keypoints from your detector then need to be shifted and re-normalized
from the interval \([-1,1]\) to the width and height of your detected
face.

When complete you should be able to produce example images like the one
below

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}64}]:} \PY{c+c1}{\PYZsh{} Load in color image for face detection}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{images/obamas4.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         
         \PY{c+c1}{\PYZsh{} Convert the image to RGB colorspace}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2RGB}\PY{p}{)}
         
         
         \PY{c+c1}{\PYZsh{} plot our image}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{9}\PY{p}{,}\PY{l+m+mi}{9}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{image copy}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}64}]:} <matplotlib.image.AxesImage at 0x1203094e0>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_73_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}65}]:} \PY{k+kn}{from} \PY{n+nn}{keras}\PY{n+nn}{.}\PY{n+nn}{models} \PY{k}{import} \PY{n}{load\PYZus{}model}
         \PY{n}{model} \PY{o}{=} \PY{n}{load\PYZus{}model}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{my\PYZus{}model.h5}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} Using the face detection code from Section 1 with our trained neural net:}
         \PY{c+c1}{\PYZsh{}\PYZsh{} * Load the model using the best discovered weights (saved to my\PYZus{}model.h5).}
         \PY{c+c1}{\PYZsh{}\PYZsh{} * Recognize faces, then predict where keypoints should go!}
         \PY{c+c1}{\PYZsh{}\PYZsh{} * Paint those predicted keypoints on the test image!}
         
         
         \PY{k}{def} \PY{n+nf}{find\PYZus{}keypoints}\PY{p}{(}\PY{n}{image}\PY{p}{)}\PY{p}{:}
             \PY{c+c1}{\PYZsh{} Convert the RGB  image to grayscale}
             \PY{n}{gray} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}RGB2GRAY}\PY{p}{)}
         
             \PY{c+c1}{\PYZsh{} Extract the pre\PYZhy{}trained face detector from an xml file}
             \PY{n}{face\PYZus{}cascade} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{CascadeClassifier}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{detector\PYZus{}architectures/haarcascade\PYZus{}frontalface\PYZus{}default.xml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
             \PY{c+c1}{\PYZsh{} Detect the faces in image}
             \PY{n}{faces} \PY{o}{=} \PY{n}{face\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{gray}\PY{p}{,} \PY{l+m+mf}{1.25}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
         
             \PY{c+c1}{\PYZsh{} Print the number of faces detected in the image}
             \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Number of faces detected:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n+nb}{len}\PY{p}{(}\PY{n}{faces}\PY{p}{)}\PY{p}{)}
         
             \PY{c+c1}{\PYZsh{} Make a copy of the orginal image to draw face detections on}
             \PY{n}{image\PYZus{}with\PYZus{}predicted\PYZus{}keypoints} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{image}\PY{p}{)}
             
             \PY{n}{faces\PYZus{}keypoints} \PY{o}{=} \PY{p}{[}\PY{p}{]}
             
             \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{faces}\PY{p}{:}
                 
                 \PY{c+c1}{\PYZsh{} Crop and resize the face to 96 x 96 }
                 \PY{n}{face\PYZus{}image} \PY{o}{=} \PY{n}{gray}\PY{p}{[}\PY{n}{y}\PY{p}{:}\PY{n}{y}\PY{o}{+}\PY{n}{h} \PY{p}{,} \PY{n}{x}\PY{p}{:}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{]}
                 \PY{n}{resize\PYZus{}face} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{resize}\PY{p}{(}\PY{n}{face\PYZus{}image}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{96}\PY{p}{,} \PY{l+m+mi}{96}\PY{p}{)}\PY{p}{)}
         
                 \PY{c+c1}{\PYZsh{} Normalize and convert to the input format}
                 \PY{n}{normalized\PYZus{}face} \PY{o}{=} \PY{n}{resize\PYZus{}face} \PY{o}{/} \PY{l+m+mi}{255}
                 \PY{n}{normalized\PYZus{}face} \PY{o}{=} \PY{n}{normalized\PYZus{}face}\PY{p}{[}\PY{n}{np}\PY{o}{.}\PY{n}{newaxis}\PY{p}{,} \PY{p}{:}\PY{p}{,} \PY{p}{:}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{newaxis}\PY{p}{]}
         
                 \PY{c+c1}{\PYZsh{} Predict the face keypoints and un\PYZhy{}normalized the coordinates}
                 \PY{n}{keypoints} \PY{o}{=} \PY{n}{model}\PY{o}{.}\PY{n}{predict}\PY{p}{(}\PY{n}{normalized\PYZus{}face}\PY{p}{)}
                 
                 \PY{c+c1}{\PYZsh{} Just tried the voodoo from earlier; why is 48 (96/2) untransform the normalization?}
                 \PY{n}{keypoints} \PY{o}{=} \PY{n}{keypoints} \PY{o}{*} \PY{l+m+mi}{48} \PY{o}{+} \PY{l+m+mi}{48}  
         
                 \PY{c+c1}{\PYZsh{} Convert keypoints to (x,y)}
                 \PY{n}{x\PYZus{}coordinate}\PY{p}{,} \PY{n}{y\PYZus{}coordinate} \PY{o}{=} \PY{n}{keypoints}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{:}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n}{keypoints}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]}
                 
                 \PY{c+c1}{\PYZsh{} Scale x, y back up to  }
                 \PY{n}{x\PYZus{}coordinate}\PY{p}{,} \PY{n}{y\PYZus{}coordinate} \PY{o}{=} \PY{n}{x} \PY{o}{+} \PY{n}{x\PYZus{}coordinate} \PY{o}{*} \PY{n}{w} \PY{o}{/} \PY{l+m+mi}{96}\PY{p}{,} \PY{n}{y} \PY{o}{+} \PY{n}{y\PYZus{}coordinate} \PY{o}{*} \PY{n}{h} \PY{o}{/} \PY{l+m+mi}{96}
                 
                 \PY{c+c1}{\PYZsh{} Use w, h to draw red boxes around the coordinates}
                 \PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}predicted\PYZus{}keypoints}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{,}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
         
                 \PY{c+c1}{\PYZsh{} Draw green circles around the keypoints!}
                 \PY{n}{faces\PYZus{}keypoints}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{p}{(}\PY{n}{x\PYZus{}coordinate}\PY{p}{,} \PY{n}{y\PYZus{}coordinate}\PY{p}{)}\PY{p}{)}
             
                 \PY{k}{for} \PY{n}{xc}\PY{p}{,} \PY{n}{yc} \PY{o+ow}{in} \PY{n+nb}{zip}\PY{p}{(}\PY{n}{x\PYZus{}coordinate}\PY{p}{,} \PY{n}{y\PYZus{}coordinate}\PY{p}{)}\PY{p}{:}
                     \PY{n}{cv2}\PY{o}{.}\PY{n}{circle}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}predicted\PYZus{}keypoints}\PY{p}{,} \PY{p}{(}\PY{n}{xc}\PY{p}{,} \PY{n}{yc}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{255}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
                      
             \PY{k}{return} \PY{n}{image\PYZus{}with\PYZus{}predicted\PYZus{}keypoints}\PY{p}{,} \PY{n}{faces\PYZus{}keypoints}
         
         \PY{c+c1}{\PYZsh{} Run Function}
         \PY{n}{image\PYZus{}with\PYZus{}predicted\PYZus{}keypoints}\PY{p}{,} \PY{n}{faces\PYZus{}keypoints} \PY{o}{=} \PY{n}{find\PYZus{}keypoints}\PY{p}{(}\PY{n}{image}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Display the image with the keypoints}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{9}\PY{p}{,}\PY{l+m+mi}{9}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image with predicted keypoints}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}predicted\PYZus{}keypoints}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Number of faces detected: 2

    \end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}65}]:} <matplotlib.image.AxesImage at 0x1205dd1d0>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_74_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    That's it! Here's what we learnt:

\subsection{Summary}\label{summary}

\textbf{Part 1} : Investigating OpenCV, pre-processing, and face
detection

\begin{itemize}
\tightlist
\item
  Section \ref{step0}: Detect Faces Using a Haar Cascade Classifier:
  Using a series of \textbf{pre-trained (cascading) classifiers} to
  identify edges and features in images.
\item
  Section \ref{step1}: Add Eye Detection: Updating the Classifier to
  \textbf{use a different set of feature weights, identifying new
  obejcts (faces AND eyes)}!
\item
  Section \ref{step2}: De-noise an Image for Better Face Detection:
  Using the \emph{expensive}
  \href{http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_photo/py_non_local_means/py_non_local_means.html}{\textbf{Gaussian
  denoising algorithm}}** to reduce the noise in image for better
  processing.
\item
  Section \ref{step3}: Blur an Image and Perform Edge Detection: Using
  the handy
  \href{http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html}{\textbf{Canny
  Edge algorithm}}, blur input images into general structures; dropping
  local noise!
\item
  Section \ref{step4}: Automatically Hide the Identity of an Individual:
  Blurring our detected faces by convolving our image with a large
  matrix of scaled ones, thereby averaging all of it together!
\end{itemize}

\textbf{Part 2} : Training a Convolutional Neural Network (CNN) to
detect facial keypoints

\begin{itemize}
\tightlist
\item
  Section \ref{step5}: Create a CNN to Recognize Facial Keypoints:
  First, we use that
  \href{https://www.kaggle.com/c/facial-keypoints-detection/data}{awesome
  dataset from Kaggle}, and prep the data for use.
\item
  Section \ref{step6}: Compile and Train the Model: We build a CNN
  leading into a Classifier, and set it to try and tag the given facial
  detection points across a series of faces.
\item
  Section \ref{step7}: Visualize the Loss and Answer Questions: Once
  we've hit very low loss (correct classifications) and improving
  accuracy (better, unbiased guess)
\end{itemize}

\textbf{Part 3} : Putting parts 1 and 2 together to identify facial
keypoints on any image!

\begin{itemize}
\tightlist
\item
  Section \ref{step7}: Build a Robust Facial Keypoints Detector
  (Complete the CV Pipeline): The magic of \texttt{model.predict()}.
\end{itemize}

    Good luck with your new face detector!

\href{http://cs231n.stanford.edu/}{\includegraphics{https://static1.squarespace.com/static/574f0b9a37013b939ab0b866/t/5936b0e717bffc7a44df2ca0/1496756488470/}}

    \subsubsection{(Optional) Further Directions - add a filter using facial
keypoints}\label{optional-further-directions---add-a-filter-using-facial-keypoints}

Using your freshly minted facial keypoint detector pipeline you can now
do things like add fun filters to a person's face automatically. In this
optional exercise you can play around with adding sunglasses
automatically to each individual's face in an image as shown in a
demonstration image below.

To produce this effect an image of a pair of sunglasses shown in the
Python cell below.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}66}]:} \PY{c+c1}{\PYZsh{} Load in sunglasses image \PYZhy{} note the usage of the special option}
         \PY{c+c1}{\PYZsh{} cv2.IMREAD\PYZus{}UNCHANGED, this option is used because the sunglasses }
         \PY{c+c1}{\PYZsh{} image has a 4th channel that allows us to control how transparent each pixel in the image is}
         \PY{n}{sunglasses} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{images/sunglasses\PYZus{}4.png}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{IMREAD\PYZus{}UNCHANGED}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Plot the image}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{sunglasses}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_78_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    This image is placed over each individual's face using the detected eye
points to determine the location of the sunglasses, and eyebrow points
to determine the size that the sunglasses should be for each person (one
could also use the nose point to determine this).

Notice that this image actually has \emph{4 channels}, not just 3.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}67}]:} \PY{c+c1}{\PYZsh{} Print out the shape of the sunglasses image}
         \PY{n+nb}{print} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{The sunglasses image has shape: }\PY{l+s+s1}{\PYZsq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{shape}\PY{p}{(}\PY{n}{sunglasses}\PY{p}{)}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
The sunglasses image has shape: (1123, 3064, 4)

    \end{Verbatim}

    It has the usual red, blue, and green channels any color image has, and
a *4th channel representing the transparency level of each pixel in the
image8.

Here's how the transparency channel works: the lower the value, the more
transparent the pixel will become. The lower bound (completely
transparent) is zero here, so any pixels set to 0 will not be seen.

\textbf{This is how we can place this image of sunglasses on someone's
face and still see the area around of their face where the sunglasses
lie - because these extra pixels in the sunglasses image have been made
completely transparent!}

Lets check out the alpha channel of our sunglasses image in the next
Python cell. Note because many of the pixels near the boundary are
transparent we'll need to explicitly print out non-zero values if we
want to see them.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}68}]:} \PY{c+c1}{\PYZsh{} Print out the sunglasses transparency (alpha) channel}
         \PY{n}{alpha\PYZus{}channel} \PY{o}{=} \PY{n}{sunglasses}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{]}
         \PY{n+nb}{print} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{the alpha channel here looks like}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n+nb}{print} \PY{p}{(}\PY{n}{alpha\PYZus{}channel}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Just to double check that there are indeed non\PYZhy{}zero values}
         \PY{c+c1}{\PYZsh{} Let\PYZsq{}s find and print out every value greater than zero}
         \PY{n}{values} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{where}\PY{p}{(}\PY{n}{alpha\PYZus{}channel} \PY{o}{!=} \PY{l+m+mi}{0}\PY{p}{)}
         \PY{n+nb}{print} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s1}{ the non\PYZhy{}zero values of the alpha channel look like}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n+nb}{print} \PY{p}{(}\PY{n}{values}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
the alpha channel here looks like
[[0 0 0 {\ldots} 0 0 0]
 [0 0 0 {\ldots} 0 0 0]
 [0 0 0 {\ldots} 0 0 0]
 {\ldots}
 [0 0 0 {\ldots} 0 0 0]
 [0 0 0 {\ldots} 0 0 0]
 [0 0 0 {\ldots} 0 0 0]]

 the non-zero values of the alpha channel look like
(array([  17,   17,   17, {\ldots}, 1109, 1109, 1109]), array([ 687,  688,  689, {\ldots}, 2376, 2377, 2378]))

    \end{Verbatim}

    This means that when we place this sunglasses image on top of another
image, we can use the transparency channel as a filter to tell us which
pixels to overlay on a new image (only the non-transparent ones with
values greater than zero).

One last thing: it's helpful to understand which keypoint belongs to the
eyes, mouth, etc. So, in the image below, we also display the index of
each facial keypoint directly on the image so that you can tell which
keypoints are for the eyes, eyebrows, etc.

With this information, we're well on our way to completing this
filtering task! Let's see if you can place the sunglasses automatically
on the individuals in the image loaded in / shown in the next Python
cell.

    \subsubsection{(Optional) Further Directions - add a filter using facial
keypoints}\label{optional-further-directions---add-a-filter-using-facial-keypoints}

Using your freshly minted facial keypoint detector pipeline you can now
do things like add fun filters to a person's face automatically. In this
optional exercise you can play around with adding sunglasses
automatically to each individual's face in an image as shown in a
demonstration image below.

To produce this effect an image of a pair of sunglasses shown in the
Python cell below.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}69}]:} \PY{c+c1}{\PYZsh{} Load in sunglasses image \PYZhy{} note the usage of the special option}
         \PY{c+c1}{\PYZsh{} cv2.IMREAD\PYZus{}UNCHANGED, this option is used because the sunglasses }
         \PY{c+c1}{\PYZsh{} image has a 4th channel that allows us to control how transparent each pixel in the image is}
         \PY{n}{sunglasses} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{images/sunglasses\PYZus{}4.png}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{IMREAD\PYZus{}UNCHANGED}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Plot the image}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{sunglasses}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_85_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    This image is placed over each individual's face using the detected eye
points to determine the location of the sunglasses, and eyebrow points
to determine the size that the sunglasses should be for each person (one
could also use the nose point to determine this).

Notice that this image actually has \emph{4 channels}, not just 3.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}70}]:} \PY{c+c1}{\PYZsh{} Print out the shape of the sunglasses image}
         \PY{n+nb}{print} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{The sunglasses image has shape: }\PY{l+s+s1}{\PYZsq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{shape}\PY{p}{(}\PY{n}{sunglasses}\PY{p}{)}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
The sunglasses image has shape: (1123, 3064, 4)

    \end{Verbatim}

    It has the usual red, blue, and green channels any color image has, and
a *4th channel representing the transparency level of each pixel in the
image8.

Here's how the transparency channel works: the lower the value, the more
transparent the pixel will become. The lower bound (completely
transparent) is zero here, so any pixels set to 0 will not be seen.

\textbf{This is how we can place this image of sunglasses on someone's
face and still see the area around of their face where the sunglasses
lie - because these extra pixels in the sunglasses image have been made
completely transparent!}

Lets check out the alpha channel of our sunglasses image in the next
Python cell. Note because many of the pixels near the boundary are
transparent we'll need to explicitly print out non-zero values if we
want to see them.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}71}]:} \PY{c+c1}{\PYZsh{} Print out the sunglasses transparency (alpha) channel}
         \PY{n}{alpha\PYZus{}channel} \PY{o}{=} \PY{n}{sunglasses}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{]}
         \PY{n+nb}{print} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{the alpha channel here looks like}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n+nb}{print} \PY{p}{(}\PY{n}{alpha\PYZus{}channel}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Just to double check that there are indeed non\PYZhy{}zero values}
         \PY{c+c1}{\PYZsh{} Let\PYZsq{}s find and print out every value greater than zero}
         \PY{n}{values} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{where}\PY{p}{(}\PY{n}{alpha\PYZus{}channel} \PY{o}{!=} \PY{l+m+mi}{0}\PY{p}{)}
         \PY{n+nb}{print} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s1}{ the non\PYZhy{}zero values of the alpha channel look like}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n+nb}{print} \PY{p}{(}\PY{n}{values}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
the alpha channel here looks like
[[0 0 0 {\ldots} 0 0 0]
 [0 0 0 {\ldots} 0 0 0]
 [0 0 0 {\ldots} 0 0 0]
 {\ldots}
 [0 0 0 {\ldots} 0 0 0]
 [0 0 0 {\ldots} 0 0 0]
 [0 0 0 {\ldots} 0 0 0]]

 the non-zero values of the alpha channel look like
(array([  17,   17,   17, {\ldots}, 1109, 1109, 1109]), array([ 687,  688,  689, {\ldots}, 2376, 2377, 2378]))

    \end{Verbatim}

    This means that when we place this sunglasses image on top of another
image, we can use the transparency channel as a filter to tell us which
pixels to overlay on a new image (only the non-transparent ones with
values greater than zero).

One last thing: it's helpful to understand which keypoint belongs to the
eyes, mouth, etc. So, in the image below, we also display the index of
each facial keypoint directly on the image so that you can tell which
keypoints are for the eyes, eyebrows, etc.

With this information, we're well on our way to completing this
filtering task! Let's see if you can place the sunglasses automatically
on the individuals in the image loaded in / shown in the next Python
cell.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}72}]:} \PY{c+c1}{\PYZsh{} Load in color image for face detection}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{images/obamas4.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Convert the image to RGB colorspace}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2RGB}\PY{p}{)}
         
         
         \PY{c+c1}{\PYZsh{} Plot the image}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Original Image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}72}]:} <matplotlib.image.AxesImage at 0x11fb0d710>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_91_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}73}]:} \PY{c+c1}{\PYZsh{}\PYZsh{} (Optional) Use the face detection code we saw in Section 1 with your trained conv\PYZhy{}net to put}
         \PY{c+c1}{\PYZsh{}\PYZsh{} sunglasses on the individuals in our test image}
\end{Verbatim}


    \subsection{Optional Animated Version!}\label{optional-animated-version}

Additional exercises to let your Laptop camera identify faces.

    \subsubsection{Further Directions - add a filter using facial keypoints
to your laptop
camera}\label{further-directions---add-a-filter-using-facial-keypoints-to-your-laptop-camera}

Now you can add the sunglasses filter to your laptop camera - as
illustrated in the gif below.

The next Python cell contains the basic laptop video camera function
used in the previous optional video exercises. Combine it with the
functionality you developed for adding sunglasses to someone's face in
the previous optional exercise and you should be good to go!

    \subsubsection{Add face and eye detection to your laptop
camera}\label{add-face-and-eye-detection-to-your-laptop-camera}

It's time to kick it up a notch, and add face and eye detection to your
laptop's camera! Afterwards, you'll be able to show off your creation
like in the gif shown below - made with a completed version of the code!

Notice that not all of the detections here are perfect - and your result
need not be perfect either. You should spend a small amount of time
tuning the parameters of your detectors to get reasonable results, but
don't hold out for perfection. If we wanted perfection we'd need to
spend a ton of time tuning the parameters of each detector, cleaning up
the input image frames, etc. You can think of this as more of a rapid
prototype.

The next cell contains code for a wrapper function called
\texttt{laptop\_camera\_face\_eye\_detector} that, when called, will
activate your laptop's camera. You will place the relevant face and eye
detection code in this wrapper function to implement face/eye detection
and mark those detections on each image frame that your camera captures.

Before adding anything to the function, you can run it to get an idea of
how it works - a small window should pop up showing you the live feed
from your camera; you can press any key to close this window.

\textbf{Note:} Mac users may find that activating this function kills
the kernel of their notebook every once in a while. If this happens to
you, just restart your notebook's kernel, activate cell(s) containing
any crucial import statements, and you'll be good to go!

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}74}]:} \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} Add face and eye detection to this laptop camera function }
         \PY{c+c1}{\PYZsh{} Make sure to draw out all faces/eyes found in each frame on the shown video feed}
         
         \PY{k+kn}{import} \PY{n+nn}{cv2}
         \PY{k+kn}{import} \PY{n+nn}{time} 
         
         \PY{c+c1}{\PYZsh{} wrapper function for face/eye detection with your laptop camera}
         \PY{k}{def} \PY{n+nf}{laptop\PYZus{}camera\PYZus{}go}\PY{p}{(}\PY{p}{)}\PY{p}{:}
             \PY{c+c1}{\PYZsh{} Create instance of video capturer}
             \PY{n}{cv2}\PY{o}{.}\PY{n}{namedWindow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
             \PY{n}{vc} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{VideoCapture}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
         
             \PY{c+c1}{\PYZsh{} Try to get the first frame}
             \PY{k}{if} \PY{n}{vc}\PY{o}{.}\PY{n}{isOpened}\PY{p}{(}\PY{p}{)}\PY{p}{:} 
                 \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
             \PY{k}{else}\PY{p}{:}
                 \PY{n}{rval} \PY{o}{=} \PY{k+kc}{False}
             
             \PY{c+c1}{\PYZsh{} Keep the video stream open}
             \PY{k}{while} \PY{n}{rval}\PY{p}{:}
                 \PY{c+c1}{\PYZsh{} Plot the image from camera with all the face and eye detections marked}
                 \PY{n}{cv2}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{frame}\PY{p}{)}
                 
                 \PY{c+c1}{\PYZsh{} Exit functionality \PYZhy{} press any key to exit laptop video}
                 \PY{n}{key} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{)}
                 \PY{k}{if} \PY{n}{key} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:} \PY{c+c1}{\PYZsh{} Exit by pressing any key}
                     \PY{c+c1}{\PYZsh{} Destroy windows }
                     \PY{n}{cv2}\PY{o}{.}\PY{n}{destroyAllWindows}\PY{p}{(}\PY{p}{)}
                     
                     \PY{c+c1}{\PYZsh{} Make sure window closes on OSx}
                     \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{)}\PY{p}{:}
                         \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
                     \PY{k}{return}
                 
                 \PY{c+c1}{\PYZsh{} Read next frame}
                 \PY{n}{time}\PY{o}{.}\PY{n}{sleep}\PY{p}{(}\PY{l+m+mf}{0.05}\PY{p}{)}             \PY{c+c1}{\PYZsh{} control framerate for computation \PYZhy{} default 20 frames per sec}
                 \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}    
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}75}]:} \PY{k+kn}{import} \PY{n+nn}{cv2}
         \PY{k+kn}{import} \PY{n+nn}{time} 
         \PY{k+kn}{from} \PY{n+nn}{keras}\PY{n+nn}{.}\PY{n+nn}{models} \PY{k}{import} \PY{n}{load\PYZus{}model}
         \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
         
         \PY{k}{def} \PY{n+nf}{laptop\PYZus{}camera\PYZus{}go}\PY{p}{(}\PY{p}{)}\PY{p}{:}
             \PY{c+c1}{\PYZsh{} Create instance of video capturer}
             \PY{n}{cv2}\PY{o}{.}\PY{n}{namedWindow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
             \PY{n}{vc} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{VideoCapture}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
         
             \PY{c+c1}{\PYZsh{} try to get the first frame}
             \PY{k}{if} \PY{n}{vc}\PY{o}{.}\PY{n}{isOpened}\PY{p}{(}\PY{p}{)}\PY{p}{:} 
                 \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
             \PY{k}{else}\PY{p}{:}
                 \PY{n}{rval} \PY{o}{=} \PY{k+kc}{False}
             
             \PY{c+c1}{\PYZsh{} Keep video stream open}
             \PY{k}{while} \PY{n}{rval}\PY{p}{:}
                 \PY{c+c1}{\PYZsh{} Plot image from camera with detections marked}
                 \PY{n}{cv2}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{frame}\PY{p}{)}
                 
                 \PY{c+c1}{\PYZsh{} Exit functionality \PYZhy{} press any key to exit laptop video}
                 \PY{n}{key} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{)}
                 \PY{k}{if} \PY{n}{key} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:} \PY{c+c1}{\PYZsh{} exit by pressing any key}
                     \PY{c+c1}{\PYZsh{} Destroy windows }
                     \PY{n}{cv2}\PY{o}{.}\PY{n}{destroyAllWindows}\PY{p}{(}\PY{p}{)}
                     
                     \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{)}\PY{p}{:}
                         \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
                     \PY{k}{return}
                 
                 \PY{c+c1}{\PYZsh{} Read next frame}
                 \PY{n}{time}\PY{o}{.}\PY{n}{sleep}\PY{p}{(}\PY{l+m+mf}{0.05}\PY{p}{)}             \PY{c+c1}{\PYZsh{} control framerate for computation \PYZhy{} default 20 frames per sec}
                 \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}    
                 
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}76}]:} \PY{c+c1}{\PYZsh{} Load facial landmark detector model}
         \PY{c+c1}{\PYZsh{} model = load\PYZus{}model(\PYZsq{}my\PYZus{}model.h5\PYZsq{})}
         
         \PY{c+c1}{\PYZsh{} Run sunglasses painter}
         \PY{c+c1}{\PYZsh{} laptop\PYZus{}camera\PYZus{}go()}
\end{Verbatim}


    \subsubsection{(Optional) Build identity protection into your laptop
camera}\label{optional-build-identity-protection-into-your-laptop-camera}

In this optional task you can add identity protection to your laptop
camera, using the previously completed code where you added face
detection to your laptop camera - and the task above. You should be able
to get reasonable results with little parameter tuning - like the one
shown in the gif below.

As with the previous video task, to make this perfect would require
significant effort - so don't strive for perfection here, strive for
reasonable quality.

The next cell contains code a wrapper function called
\texttt{laptop\_camera\_identity\_hider} that - when called - will
activate your laptop's camera. You need to place the relevant face
detection and blurring code developed above in this function in order to
blur faces entering your laptop camera's field of view.

Before adding anything to the function you can call it to get a hang of
how it works - a small window will pop up showing you the live feed from
your camera, you can press any key to close this window.

\textbf{Note:} Mac users may find that activating this function kills
the kernel of their notebook every once in a while. If this happens to
you, just restart your notebook's kernel, activate cell(s) containing
any crucial import statements, and you'll be good to go!

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}77}]:} \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} Insert face detection and blurring code into the wrapper below to create an identity protector on your laptop!}
         \PY{k+kn}{import} \PY{n+nn}{cv2}
         \PY{k+kn}{import} \PY{n+nn}{time} 
         
         \PY{k}{def} \PY{n+nf}{laptop\PYZus{}camera\PYZus{}go}\PY{p}{(}\PY{p}{)}\PY{p}{:}
             \PY{c+c1}{\PYZsh{} Create instance of video capturer}
             \PY{n}{cv2}\PY{o}{.}\PY{n}{namedWindow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
             \PY{n}{vc} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{VideoCapture}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
         
             \PY{c+c1}{\PYZsh{} Try to get the first frame}
             \PY{k}{if} \PY{n}{vc}\PY{o}{.}\PY{n}{isOpened}\PY{p}{(}\PY{p}{)}\PY{p}{:} 
                 \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
             \PY{k}{else}\PY{p}{:}
                 \PY{n}{rval} \PY{o}{=} \PY{k+kc}{False}
             
             \PY{c+c1}{\PYZsh{} Keep video stream open}
             \PY{k}{while} \PY{n}{rval}\PY{p}{:}
                 \PY{c+c1}{\PYZsh{} Plot image from camera with detections marked}
                 \PY{n}{cv2}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{frame}\PY{p}{)}
                 
                 \PY{c+c1}{\PYZsh{} Exit functionality \PYZhy{} press any key to exit laptop video}
                 \PY{n}{key} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{)}
                 \PY{k}{if} \PY{n}{key} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:} \PY{c+c1}{\PYZsh{} Exit by pressing any key}
                     \PY{c+c1}{\PYZsh{} Destroy windows}
                     \PY{n}{cv2}\PY{o}{.}\PY{n}{destroyAllWindows}\PY{p}{(}\PY{p}{)}
                     
                     \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{)}\PY{p}{:}
                         \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
                     \PY{k}{return}
                 
                 \PY{c+c1}{\PYZsh{} Read next frame}
                 \PY{n}{time}\PY{o}{.}\PY{n}{sleep}\PY{p}{(}\PY{l+m+mf}{0.05}\PY{p}{)}             \PY{c+c1}{\PYZsh{} control framerate for computation \PYZhy{} default 20 frames per sec}
                 \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}    
                 
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}78}]:} \PY{c+c1}{\PYZsh{} Run laptop identity hider}
         \PY{c+c1}{\PYZsh{}laptop\PYZus{}camera\PYZus{}go()}
\end{Verbatim}


    \subsubsection{(Optional) Further Directions - add a filter using facial
keypoints to your laptop
camera}\label{optional-further-directions---add-a-filter-using-facial-keypoints-to-your-laptop-camera}

Now you can add facial keypoint detection to your laptop camera - as
illustrated in the gif below.

The next Python cell contains the basic laptop video camera function
used in the previous optional video exercises. Combine it with the
functionality you developed for keypoint detection and marking in the
previous exercise and you should be good to go!

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}79}]:} \PY{k+kn}{import} \PY{n+nn}{cv2}
         \PY{k+kn}{import} \PY{n+nn}{time} 
         \PY{k+kn}{from} \PY{n+nn}{keras}\PY{n+nn}{.}\PY{n+nn}{models} \PY{k}{import} \PY{n}{load\PYZus{}model}
         \PY{k}{def} \PY{n+nf}{laptop\PYZus{}camera\PYZus{}go}\PY{p}{(}\PY{p}{)}\PY{p}{:}
             \PY{c+c1}{\PYZsh{} Create instance of video capturer}
             \PY{n}{cv2}\PY{o}{.}\PY{n}{namedWindow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
             \PY{n}{vc} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{VideoCapture}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
         
             \PY{c+c1}{\PYZsh{} Try to get the first frame}
             \PY{k}{if} \PY{n}{vc}\PY{o}{.}\PY{n}{isOpened}\PY{p}{(}\PY{p}{)}\PY{p}{:} 
                 \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
             \PY{k}{else}\PY{p}{:}
                 \PY{n}{rval} \PY{o}{=} \PY{k+kc}{False}
             
             \PY{c+c1}{\PYZsh{} keep video stream open}
             \PY{k}{while} \PY{n}{rval}\PY{p}{:}
                 \PY{c+c1}{\PYZsh{} plot image from camera with detections marked}
                 \PY{n}{cv2}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{frame}\PY{p}{)}
                 
                 \PY{c+c1}{\PYZsh{} exit functionality \PYZhy{} press any key to exit laptop video}
                 \PY{n}{key} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{)}
                 \PY{k}{if} \PY{n}{key} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:} \PY{c+c1}{\PYZsh{} exit by pressing any key}
                     \PY{c+c1}{\PYZsh{} destroy windows}
                     \PY{n}{cv2}\PY{o}{.}\PY{n}{destroyAllWindows}\PY{p}{(}\PY{p}{)}
                     
                     \PY{c+c1}{\PYZsh{} hack from stack overflow for making sure window closes on osx \PYZhy{}\PYZhy{}\PYZgt{} https://stackoverflow.com/questions/6116564/destroywindow\PYZhy{}does\PYZhy{}not\PYZhy{}close\PYZhy{}window\PYZhy{}on\PYZhy{}mac\PYZhy{}using\PYZhy{}python\PYZhy{}and\PYZhy{}opencv}
                     \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{)}\PY{p}{:}
                         \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
                     \PY{k}{return}
                 
                 \PY{c+c1}{\PYZsh{} read next frame}
                 \PY{n}{time}\PY{o}{.}\PY{n}{sleep}\PY{p}{(}\PY{l+m+mf}{0.05}\PY{p}{)}             \PY{c+c1}{\PYZsh{} control framerate for computation \PYZhy{} default 20 frames per sec}
                 \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}  
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}80}]:} \PY{c+c1}{\PYZsh{} Run your keypoint face painter}
         \PY{c+c1}{\PYZsh{} laptop\PYZus{}camera\PYZus{}go()}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}81}]:} \PY{c+c1}{\PYZsh{}\PYZsh{} (Optional) Use the face detection code we saw in Section 1 with your trained conv\PYZhy{}net to put}
         \PY{c+c1}{\PYZsh{}\PYZsh{} sunglasses on the individuals in our test image}
\end{Verbatim}


    \subsubsection{Further Directions - add a filter using facial keypoints
to your laptop
camera}\label{further-directions---add-a-filter-using-facial-keypoints-to-your-laptop-camera}

Now you can add the sunglasses filter to your laptop camera - as
illustrated in the gif below.

The next Python cell contains the basic laptop video camera function
used in the previous optional video exercises. Combine it with the
functionality you developed for adding sunglasses to someone's face in
the previous optional exercise and you should be good to go!

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}82}]:} \PY{k+kn}{import} \PY{n+nn}{cv2}
         \PY{k+kn}{import} \PY{n+nn}{time} 
         \PY{k+kn}{from} \PY{n+nn}{keras}\PY{n+nn}{.}\PY{n+nn}{models} \PY{k}{import} \PY{n}{load\PYZus{}model}
         \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
         
         \PY{k}{def} \PY{n+nf}{laptop\PYZus{}camera\PYZus{}go}\PY{p}{(}\PY{p}{)}\PY{p}{:}
             \PY{c+c1}{\PYZsh{} Create instance of video capturer}
             \PY{n}{cv2}\PY{o}{.}\PY{n}{namedWindow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
             \PY{n}{vc} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{VideoCapture}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
         
             \PY{c+c1}{\PYZsh{} try to get the first frame}
             \PY{k}{if} \PY{n}{vc}\PY{o}{.}\PY{n}{isOpened}\PY{p}{(}\PY{p}{)}\PY{p}{:} 
                 \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
             \PY{k}{else}\PY{p}{:}
                 \PY{n}{rval} \PY{o}{=} \PY{k+kc}{False}
             
             \PY{c+c1}{\PYZsh{} Keep video stream open}
             \PY{k}{while} \PY{n}{rval}\PY{p}{:}
                 \PY{c+c1}{\PYZsh{} Plot image from camera with detections marked}
                 \PY{n}{cv2}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{frame}\PY{p}{)}
                 
                 \PY{c+c1}{\PYZsh{} Exit functionality \PYZhy{} press any key to exit laptop video}
                 \PY{n}{key} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{)}
                 \PY{k}{if} \PY{n}{key} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:} \PY{c+c1}{\PYZsh{} exit by pressing any key}
                     \PY{c+c1}{\PYZsh{} Destroy windows }
                     \PY{n}{cv2}\PY{o}{.}\PY{n}{destroyAllWindows}\PY{p}{(}\PY{p}{)}
                     
                     \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{)}\PY{p}{:}
                         \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
                     \PY{k}{return}
                 
                 \PY{c+c1}{\PYZsh{} Read next frame}
                 \PY{n}{time}\PY{o}{.}\PY{n}{sleep}\PY{p}{(}\PY{l+m+mf}{0.05}\PY{p}{)}             \PY{c+c1}{\PYZsh{} control framerate for computation \PYZhy{} default 20 frames per sec}
                 \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}83}]:} \PY{c+c1}{\PYZsh{} Load facial landmark detector model}
         \PY{n}{model} \PY{o}{=} \PY{n}{load\PYZus{}model}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{my\PYZus{}model.h5}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Run sunglasses painter}
         \PY{c+c1}{\PYZsh{} laptop\PYZus{}camera\PYZus{}go()}
\end{Verbatim}



    % Add a bibliography block to the postdoc
    
    
    
    \end{document}
